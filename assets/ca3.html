<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Dual Layer Game of Life</title>
    <style>
        body {
            margin: 0;
            padding: 20px;
            background: linear-gradient(135deg, #0f0f23, #1a1a2e);
            color: #e0e0e0;
            font-family: 'Courier New', monospace;
            min-height: 100vh;
            overflow-x: auto;
        }

        .container {
            max-width: 1800px;
            margin: 0 auto;
            padding: 0 10px;
        }

        h1 {
            text-align: center;
            color: #00ff88;
            text-shadow: 0 0 10px rgba(0, 255, 136, 0.3);
            margin-bottom: 30px;
        }

        .controls {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 20px;
            margin-bottom: 30px;
            padding: 20px;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 15px;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(0, 255, 136, 0.1);
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
        }

        .control-group {
            display: flex;
            flex-direction: column;
            gap: 10px;
            padding: 15px;
            background: rgba(255, 255, 255, 0.03);
            border-radius: 10px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            transition: all 0.3s ease;
        }

        .control-group:hover {
            background: rgba(255, 255, 255, 0.05);
            border-color: rgba(0, 255, 136, 0.3);
            transform: translateY(-2px);
            box-shadow: 0 4px 15px rgba(0, 255, 136, 0.1);
        }

        .control-group label {
            color: #00ff88;
            font-weight: bold;
            font-size: 13px;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            margin-bottom: 5px;
        }

        .layer-header {
            color: #ff6b6b;
            font-size: 14px;
            font-weight: bold;
            text-transform: uppercase;
            letter-spacing: 1px;
            margin-bottom: 10px;
            padding: 8px;
            background: rgba(255, 107, 107, 0.1);
            border-radius: 5px;
            text-align: center;
        }

        .layer-header.layer2 {
            color: #4ecdc4;
            background: rgba(78, 205, 196, 0.1);
        }

        input[type="range"] {
            width: 100%;
            height: 8px;
            border-radius: 4px;
            background: #333;
            outline: none;
            -webkit-appearance: none;
        }

        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: #00ff88;
            cursor: pointer;
            box-shadow: 0 0 10px rgba(0, 255, 136, 0.5);
        }

        input[type="range"]::-moz-range-thumb {
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: #00ff88;
            cursor: pointer;
            border: none;
            box-shadow: 0 0 10px rgba(0, 255, 136, 0.5);
        }

        select, input[type="number"], input[type="text"] {
            padding: 8px;
            border-radius: 8px;
            border: 1px solid #444;
            background: rgba(0, 0, 0, 0.3);
            color: #e0e0e0;
            font-family: inherit;
            transition: all 0.3s ease;
        }

        select:focus, input[type="number"]:focus, input[type="text"]:focus {
            outline: none;
            border-color: #00ff88;
            box-shadow: 0 0 10px rgba(0, 255, 136, 0.3);
        }

        .buttons {
            display: flex;
            gap: 15px;
            flex-wrap: wrap;
            justify-content: center;
            margin-bottom: 20px;
            padding: 20px;
            background: rgba(255, 255, 255, 0.03);
            border-radius: 15px;
            border: 1px solid rgba(255, 255, 255, 0.1);
        }

        button {
            padding: 12px 24px;
            border: none;
            border-radius: 25px;
            background: linear-gradient(45deg, #00ff88, #00cc6a);
            color: #000;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s ease;
            font-family: inherit;
            box-shadow: 0 4px 15px rgba(0, 255, 136, 0.3);
        }

        button:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(0, 255, 136, 0.4);
        }

        button:active {
            transform: translateY(0);
        }

        button.secondary {
            background: linear-gradient(45deg, #666, #888);
            color: #fff;
            box-shadow: 0 4px 15px rgba(255, 255, 255, 0.1);
        }

        button.secondary:hover {
            box-shadow: 0 6px 20px rgba(255, 255, 255, 0.2);
        }

        .canvas-container {
            display: flex;
            justify-content: center;
            margin-bottom: 20px;
            padding: 20px;
            background: rgba(255, 255, 255, 0.03);
            border-radius: 15px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            transition: all 0.5s ease;
            position: relative;
        }

        .canvas-container.zoomed {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            margin: 0;
            padding: 20px;
            background: rgba(0, 0, 0, 0.95);
            border-radius: 0;
            z-index: 1000;
            backdrop-filter: blur(10px);
        }

        canvas {
            border: 2px solid #00ff88;
            border-radius: 10px;
            background: #000;
            box-shadow: 0 0 40px rgba(0, 255, 136, 0.4), inset 0 0 20px rgba(0, 0, 0, 0.5);
            transition: all 0.3s ease;
            cursor: pointer;
        }

        canvas:hover {
            box-shadow: 0 0 50px rgba(0, 255, 136, 0.6), inset 0 0 20px rgba(0, 0, 0, 0.5);
            transform: scale(1.02);
        }

        .canvas-container.zoomed canvas {
            max-width: calc(100vw - 40px);
            max-height: calc(100vh - 40px);
            width: auto;
            height: auto;
            transform: none;
        }

        .canvas-container.zoomed canvas:hover {
            transform: none;
        }

        .zoom-hint {
            position: absolute;
            top: 10px;
            right: 10px;
            background: rgba(0, 255, 136, 0.2);
            color: #00ff88;
            padding: 8px 12px;
            border-radius: 20px;
            font-size: 12px;
            opacity: 0;
            transition: opacity 0.3s ease;
            pointer-events: none;
            backdrop-filter: blur(5px);
            border: 1px solid rgba(0, 255, 136, 0.3);
        }

        .canvas-container:hover .zoom-hint {
            opacity: 1;
        }

        .canvas-container.zoomed .zoom-hint {
            opacity: 1;
            background: rgba(255, 255, 255, 0.2);
            color: #fff;
        }

        .stats {
            text-align: center;
            font-size: 14px;
            color: #888;
            display: flex;
            justify-content: center;
            gap: 30px;
            flex-wrap: wrap;
            padding: 20px;
            background: rgba(255, 255, 255, 0.03);
            border-radius: 15px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            margin-bottom: 20px;
        }

        .stat {
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 15px;
            background: rgba(0, 0, 0, 0.2);
            border-radius: 10px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            transition: all 0.3s ease;
            min-width: 80px;
        }

        .stat:hover {
            background: rgba(0, 0, 0, 0.3);
            border-color: rgba(0, 255, 136, 0.3);
            transform: translateY(-2px);
        }

        .stat-value {
            color: #00ff88;
            font-weight: bold;
            font-size: 24px;
            text-shadow: 0 0 10px rgba(0, 255, 136, 0.5);
            margin-bottom: 5px;
        }

        .stat-value.layer1 {
            color: #ff6b6b;
            text-shadow: 0 0 10px rgba(255, 107, 107, 0.5);
        }

        .stat-value.layer2 {
            color: #4ecdc4;
            text-shadow: 0 0 10px rgba(78, 205, 196, 0.5);
        }

        .stat-label {
            font-size: 12px;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            color: #aaa;
        }

        .info {
            margin-top: 20px;
            padding: 20px;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 15px;
            backdrop-filter: blur(10px);
            font-size: 14px;
            line-height: 1.6;
            border: 1px solid rgba(0, 255, 136, 0.1);
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
        }

        .info h3 {
            color: #00ff88;
            margin-top: 0;
            text-shadow: 0 0 10px rgba(0, 255, 136, 0.3);
            border-bottom: 2px solid rgba(0, 255, 136, 0.3);
            padding-bottom: 10px;
            margin-bottom: 20px;
        }

        .info p {
            margin-bottom: 15px;
        }

        .info strong {
            color: #00ff88;
            text-shadow: 0 0 5px rgba(0, 255, 136, 0.3);
        }

        .layer-indicator {
            position: absolute;
            top: 10px;
            left: 10px;
            background: rgba(0, 0, 0, 0.7);
            color: #fff;
            padding: 5px 10px;
            border-radius: 15px;
            font-size: 12px;
            font-weight: bold;
        }

        /* Responsive design */
        @media (max-width: 1200px) {
            .controls {
                grid-template-columns: repeat(auto-fit, minmax(220px, 1fr));
                gap: 15px;
                padding: 15px;
            }

            .control-group {
                padding: 12px;
            }

            .buttons {
                gap: 10px;
            }

            .stats {
                gap: 20px;
            }
        }

        @media (max-width: 768px) {
            body {
                padding: 10px;
            }

            .controls {
                grid-template-columns: 1fr;
                gap: 10px;
                padding: 10px;
            }

            .control-group {
                padding: 10px;
            }

            .buttons {
                flex-direction: column;
                align-items: center;
            }

            button {
                width: 200px;
            }

            .stats {
                flex-direction: column;
                gap: 10px;
            }

            .stat {
                width: 100%;
                max-width: 200px;
                margin: 0 auto;
            }

            .canvas-container {
                padding: 10px;
            }

            canvas {
                max-width: 100%;
                height: auto;
            }
        }

        /* Enhanced visual effects */
        .container::before {
            content: '';
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: radial-gradient(circle at 20% 50%, rgba(0, 255, 136, 0.1) 0%, transparent 50%),
            radial-gradient(circle at 80% 20%, rgba(255, 107, 107, 0.05) 0%, transparent 50%),
            radial-gradient(circle at 40% 80%, rgba(78, 205, 196, 0.03) 0%, transparent 50%);
            pointer-events: none;
            z-index: -1;
        }
    </style>
</head>
<body>
<div class="container">
    <h1>Dual Layer Game of Life</h1>

    <div class="controls">
        <div class="control-group">
            <label>Simulation Speed</label>
            <input type="range" id="speed" min="1" max="2000" value="100">
            <span id="speedValue">100 ms</span>
        </div>

        <div class="control-group">
            <label>Layer 1 Step Ratio</label>
            <input type="range" id="layer1Ratio" min="1" max="10" value="2">
            <span id="layer1RatioValue">1:2 (Layer1:Layer2)</span>
        </div>

        <div class="control-group">
            <label>Grid Size</label>
            <select id="gridSize">
                <option value="50">50x50</option>
                <option value="75">75x75</option>
                <option value="100" selected>100x100</option>
                <option value="125">125x125</option>
                <option value="150">150x150</option>
                <option value="200">200x200</option>
            </select>
        </div>

        <div class="control-group">
            <label>Display Mode</label>
            <select id="displayMode">
                <option value="combined">Combined View</option>
                <option value="layer1">Layer 1 Only</option>
                <option value="layer2">Layer 2 Only</option>
                <option value="difference">Difference</option>
            </select>
        </div>

        <div class="control-group">
            <div class="layer-header">Layer 1 (Base)</div>
            <label>Birth Rule</label>
            <input type="number" id="layer1Birth" min="0" max="8" value="3">
        </div>

        <div class="control-group">
            <label>Survival Min</label>
            <input type="number" id="layer1SurvivalMin" min="0" max="8" value="2">
        </div>

        <div class="control-group">
            <label>Survival Max</label>
            <input type="number" id="layer1SurvivalMax" min="0" max="8" value="3">
        </div>

        <div class="control-group">
            <label>Neighborhood Radius</label>
            <input type="range" id="layer1Radius" min="1" max="3" value="1">
            <span id="layer1RadiusValue">1</span>
        </div>

        <div class="control-group">
            <div class="layer-header layer2">Layer 2 (Influenced)</div>
            <label>Birth Rule</label>
            <input type="number" id="layer2Birth" min="0" max="12" value="3">
        </div>

        <div class="control-group">
            <label>Survival Min</label>
            <input type="number" id="layer2SurvivalMin" min="0" max="12" value="2">
        </div>

        <div class="control-group">
            <label>Survival Max</label>
            <input type="number" id="layer2SurvivalMax" min="0" max="12" value="3">
        </div>

        <div class="control-group">
            <label>Neighborhood Radius</label>
            <input type="range" id="layer2Radius" min="1" max="3" value="1">
            <span id="layer2RadiusValue">1</span>
        </div>

        <div class="control-group">
            <label>Layer 1 Influence Strength</label>
            <input type="range" id="influenceStrength" min="0" max="100" value="30">
            <span id="influenceStrengthValue">30%</span>
        </div>

        <div class="control-group">
            <label>Influence Mode</label>
            <select id="influenceMode">
                <option value="additive">Additive</option>
                <option value="inhibitive">Inhibitive</option>
                <option value="catalytic">Catalytic</option>
                <option value="competitive">Competitive</option>
            </select>
        </div>

        <div class="control-group">
            <label>Initial Pattern</label>
            <select id="initialPattern">
                <option value="random">Random</option>
                <option value="glider">Gliders</option>
                <option value="oscillators">Oscillators</option>
                <option value="still">Still Lifes</option>
                <option value="custom">Custom Shapes</option>
            </select>
        </div>
    </div>

    <div class="buttons">
        <button id="startStop">Start</button>
        <button id="step" class="secondary">Step</button>
        <button id="reset" class="secondary">Reset</button>
        <button id="randomize">Randomize</button>
        <button id="clearLayer1" class="secondary">Clear Layer 1</button>
        <button id="clearLayer2" class="secondary">Clear Layer 2</button>
    </div>

    <div class="canvas-container">
        <canvas id="canvas" width="600" height="600"></canvas>
        <div class="zoom-hint">Click to zoom</div>
        <div class="layer-indicator" id="layerIndicator">Combined View</div>
    </div>

    <div class="stats">
        <div class="stat">
            <div class="stat-value" id="generation">0</div>
            <div class="stat-label">Generation</div>
        </div>
        <div class="stat">
            <div class="stat-value layer1" id="layer1Cells">0</div>
            <div class="stat-label">Layer 1 Cells</div>
        </div>
        <div class="stat">
            <div class="stat-value layer2" id="layer2Cells">0</div>
            <div class="stat-label">Layer 2 Cells</div>
        </div>
        <div class="stat">
            <div class="stat-value" id="totalCells">0</div>
            <div class="stat-label">Total Active</div>
        </div>
        <div class="stat">
            <div class="stat-value" id="layer1Generation">0</div>
            <div class="stat-label">Layer 1 Gen</div>
        </div>
        <div class="stat">
            <div class="stat-value" id="influenceCount">0</div>
            <div class="stat-label">Influences</div>
        </div>
    </div>

    <div class="info">
        <h3>Dual Layer Game of Life System</h3>
        <p><strong>Layer 1 (Base Layer):</strong> Runs a standard Game of Life with configurable rules at a slower pace. This layer establishes the foundational patterns and structures.</p>
        <p><strong>Layer 2 (Influenced Layer):</strong> Runs its own Game of Life rules but is influenced by Layer 1's state. The influence can be additive (Layer 1 cells count as neighbors), inhibitive (Layer 1 cells prevent birth/survival), catalytic (Layer 1 cells enable special rules), or competitive (layers compete for space).</p>
        <p><strong>Step Ratio System:</strong> Layer 1 evolves every N steps while Layer 2 evolves every step, creating temporal dynamics where slow foundational changes influence rapid surface evolution.</p>
        <p><strong>Influence Modes:</strong>
            <br>• <strong>Additive:</strong> Layer 1 cells contribute to neighbor counts for Layer 2
            <br>• <strong>Inhibitive:</strong> Layer 1 cells prevent Layer 2 birth/survival
            <br>• <strong>Catalytic:</strong> Layer 1 cells enable special birth conditions
            <br>• <strong>Competitive:</strong> Layers compete, with Layer 1 potentially overriding Layer 2
        </p>
        <p><strong>Emergent Behaviors:</strong> The interaction between fast and slow evolution rates creates complex dynamics including stable foundations with dynamic surfaces, wave propagation through layered media, and hierarchical pattern formation.</p>
    </div>
</div>

<script>
    class DualLayerGameOfLife {
        constructor() {
            this.canvas = document.getElementById('canvas');
            this.ctx = this.canvas.getContext('2d');
            this.imageData = null;
            this.pixelData = null;
            this.gridSize = 100;
            this.cellSize = 6;
            this.running = false;
            this.generation = 0;
            this.layer1Generation = 0;
            this.isZoomed = false;

            // Layer grids
            this.layer1Grid = [];
            this.layer2Grid = [];
            this.layer1NextGrid = [];
            this.layer2NextGrid = [];

            // Parameters
            this.speed = 100;
            this.layer1StepRatio = 2;
            this.stepCounter = 0;

            // Layer 1 rules
            this.layer1Birth = 3;
            this.layer1SurvivalMin = 2;
            this.layer1SurvivalMax = 3;
            this.layer1Radius = 1;

            // Layer 2 rules
            this.layer2Birth = 3;
            this.layer2SurvivalMin = 2;
            this.layer2SurvivalMax = 3;
            this.layer2Radius = 1;

            // Influence parameters
            this.influenceStrength = 0.3;
            this.influenceMode = 'additive';
            this.displayMode = 'combined';
            this.initialPattern = 'random';

            this.setupEventListeners();
            this.updateCanvasSize();
            this.reset();
        }

        setupEventListeners() {
            document.getElementById('startStop').addEventListener('click', () => this.toggleSimulation());
            document.getElementById('step').addEventListener('click', () => this.step());
            document.getElementById('reset').addEventListener('click', () => this.reset());
            document.getElementById('randomize').addEventListener('click', () => this.randomize());
            document.getElementById('clearLayer1').addEventListener('click', () => this.clearLayer1());
            document.getElementById('clearLayer2').addEventListener('click', () => this.clearLayer2());

            // Canvas zoom functionality
            this.canvas.addEventListener('click', (e) => {
                e.preventDefault();
                this.toggleZoom();
            });

            // ESC key to exit zoom
            document.addEventListener('keydown', (e) => {
                if (e.key === 'Escape' && this.isZoomed) {
                    this.toggleZoom();
                }
            });

            // Handle window resize when zoomed
            window.addEventListener('resize', () => {
                if (this.isZoomed) {
                    this.updateZoomedCanvasSize();
                }
            });

            document.getElementById('speed').addEventListener('input', (e) => {
                this.speed = parseInt(e.target.value);
                const speedText = this.speed >= 1000 ?
                    (this.speed / 1000).toFixed(1) + ' s' :
                    this.speed + ' ms';
                document.getElementById('speedValue').textContent = speedText;
            });

            document.getElementById('layer1Ratio').addEventListener('input', (e) => {
                this.layer1StepRatio = parseInt(e.target.value);
                document.getElementById('layer1RatioValue').textContent = `1:${this.layer1StepRatio} (Layer1:Layer2)`;
            });

            document.getElementById('gridSize').addEventListener('change', (e) => {
                this.gridSize = parseInt(e.target.value);
                this.updateCanvasSize();
                this.reset();
            });

            document.getElementById('displayMode').addEventListener('change', (e) => {
                this.displayMode = e.target.value;
                document.getElementById('layerIndicator').textContent = this.getDisplayModeText();
                this.draw();
            });

            // Layer 1 controls
            document.getElementById('layer1Birth').addEventListener('input', (e) => {
                this.layer1Birth = parseInt(e.target.value);
            });

            document.getElementById('layer1SurvivalMin').addEventListener('input', (e) => {
                this.layer1SurvivalMin = parseInt(e.target.value);
            });

            document.getElementById('layer1SurvivalMax').addEventListener('input', (e) => {
                this.layer1SurvivalMax = parseInt(e.target.value);
            });

            document.getElementById('layer1Radius').addEventListener('input', (e) => {
                this.layer1Radius = parseInt(e.target.value);
                document.getElementById('layer1RadiusValue').textContent = this.layer1Radius;
            });

            // Layer 2 controls
            document.getElementById('layer2Birth').addEventListener('input', (e) => {
                this.layer2Birth = parseInt(e.target.value);
            });

            document.getElementById('layer2SurvivalMin').addEventListener('input', (e) => {
                this.layer2SurvivalMin = parseInt(e.target.value);
            });

            document.getElementById('layer2SurvivalMax').addEventListener('input', (e) => {
                this.layer2SurvivalMax = parseInt(e.target.value);
            });

            document.getElementById('layer2Radius').addEventListener('input', (e) => {
                this.layer2Radius = parseInt(e.target.value);
                document.getElementById('layer2RadiusValue').textContent = this.layer2Radius;
            });

            document.getElementById('influenceStrength').addEventListener('input', (e) => {
                this.influenceStrength = parseInt(e.target.value) / 100;
                document.getElementById('influenceStrengthValue').textContent = parseInt(e.target.value) + '%';
            });

            document.getElementById('influenceMode').addEventListener('change', (e) => {
                this.influenceMode = e.target.value;
            });

            document.getElementById('initialPattern').addEventListener('change', (e) => {
                this.initialPattern = e.target.value;
            });
        }

        getDisplayModeText() {
            switch (this.displayMode) {
                case 'combined': return 'Combined View';
                case 'layer1': return 'Layer 1 Only';
                case 'layer2': return 'Layer 2 Only';
                case 'difference': return 'Difference View';
                default: return 'Combined View';
            }
        }

        updateCanvasSize() {
            if (this.isZoomed) {
                this.updateZoomedCanvasSize();
            } else {
                this.updateNormalCanvasSize();
            }
        }

        updateNormalCanvasSize() {
            const maxCanvasSize = Math.min(window.innerWidth * 0.8, window.innerHeight * 0.6, 800);
            this.cellSize = Math.max(1, Math.floor(maxCanvasSize / this.gridSize));
            const actualCanvasSize = this.gridSize * this.cellSize;
            this.canvas.width = actualCanvasSize;
            this.canvas.height = actualCanvasSize;
            this.imageData = this.ctx.createImageData(actualCanvasSize, actualCanvasSize);
            this.pixelData = this.imageData.data;
        }

        updateZoomedCanvasSize() {
            const maxWidth = window.innerWidth - 40;
            const maxHeight = window.innerHeight - 40;
            const maxCanvasSize = Math.min(maxWidth, maxHeight);
            this.cellSize = Math.max(1, Math.floor(maxCanvasSize / this.gridSize));
            const actualCanvasSize = this.gridSize * this.cellSize;
            this.canvas.width = actualCanvasSize;
            this.canvas.height = actualCanvasSize;
            this.imageData = this.ctx.createImageData(actualCanvasSize, actualCanvasSize);
            this.pixelData = this.imageData.data;
        }

        toggleZoom() {
            this.isZoomed = !this.isZoomed;
            const container = document.querySelector('.canvas-container');
            const hint = document.querySelector('.zoom-hint');

            if (this.isZoomed) {
                container.classList.add('zoomed');
                hint.textContent = 'Click or press ESC to exit zoom';
                document.body.style.overflow = 'hidden';
                this.updateZoomedCanvasSize();
            } else {
                container.classList.remove('zoomed');
                hint.textContent = 'Click to zoom';
                document.body.style.overflow = '';
                this.updateNormalCanvasSize();
            }

            this.draw();
        }

        reset() {
            this.running = false;
            this.generation = 0;
            this.layer1Generation = 0;
            this.stepCounter = 0;

            this.initializeGrids();
            this.generateInitialPattern();

            document.getElementById('startStop').textContent = 'Start';
            this.updateStats();
            this.draw();
        }

        initializeGrids() {
            this.layer1Grid = new Array(this.gridSize).fill(null).map(() => new Array(this.gridSize).fill(0));
            this.layer2Grid = new Array(this.gridSize).fill(null).map(() => new Array(this.gridSize).fill(0));
            this.layer1NextGrid = new Array(this.gridSize).fill(null).map(() => new Array(this.gridSize).fill(0));
            this.layer2NextGrid = new Array(this.gridSize).fill(null).map(() => new Array(this.gridSize).fill(0));
        }

        generateInitialPattern() {
            switch (this.initialPattern) {
                case 'random':
                    this.generateRandomPattern();
                    break;
                case 'glider':
                    this.generateGliders();
                    break;
                case 'oscillators':
                    this.generateOscillators();
                    break;
                case 'still':
                    this.generateStillLifes();
                    break;
                case 'custom':
                    this.generateCustomShapes();
                    break;
            }
        }

        generateRandomPattern() {
            for (let y = 0; y < this.gridSize; y++) {
                for (let x = 0; x < this.gridSize; x++) {
                    this.layer1Grid[y][x] = Math.random() < 0.15 ? 1 : 0;
                    this.layer2Grid[y][x] = Math.random() < 0.2 ? 1 : 0;
                }
            }
        }

        generateGliders() {
            const gliderPattern = [
                [0, 1, 0],
                [0, 0, 1],
                [1, 1, 1]
            ];

            // Place gliders in layer 1
            for (let i = 0; i < 3; i++) {
                const x = Math.floor(Math.random() * (this.gridSize - 10)) + 5;
                const y = Math.floor(Math.random() * (this.gridSize - 10)) + 5;
                this.placePattern(this.layer1Grid, gliderPattern, x, y);
            }

            // Place different gliders in layer 2
            for (let i = 0; i < 4; i++) {
                const x = Math.floor(Math.random() * (this.gridSize - 10)) + 5;
                const y = Math.floor(Math.random() * (this.gridSize - 10)) + 5;
                this.placePattern(this.layer2Grid, gliderPattern, x, y);
            }
        }

        generateOscillators() {
            const blinker = [[1, 1, 1]];
            const toad = [
                [0, 1, 1, 1],
                [1, 1, 1, 0]
            ];

            // Place oscillators in both layers
            for (let i = 0; i < 5; i++) {
                const x = Math.floor(Math.random() * (this.gridSize - 10)) + 5;
                const y = Math.floor(Math.random() * (this.gridSize - 10)) + 5;
                const pattern = Math.random() < 0.5 ? blinker : toad;
                this.placePattern(this.layer1Grid, pattern, x, y);
            }

            for (let i = 0; i < 6; i++) {
                const x = Math.floor(Math.random() * (this.gridSize - 10)) + 5;
                const y = Math.floor(Math.random() * (this.gridSize - 10)) + 5;
                const pattern = Math.random() < 0.5 ? blinker : toad;
                this.placePattern(this.layer2Grid, pattern, x, y);
            }
        }

        generateStillLifes() {
            const block = [
                [1, 1],
                [1, 1]
            ];
            const beehive = [
                [0, 1, 1, 0],
                [1, 0, 0, 1],
                [0, 1, 1, 0]
            ];

            for (let i = 0; i < 8; i++) {
                const x = Math.floor(Math.random() * (this.gridSize - 10)) + 5;
                const y = Math.floor(Math.random() * (this.gridSize - 10)) + 5;
                const pattern = Math.random() < 0.6 ? block : beehive;
                this.placePattern(this.layer1Grid, pattern, x, y);
            }

            for (let i = 0; i < 10; i++) {
                const x = Math.floor(Math.random() * (this.gridSize - 10)) + 5;
                const y = Math.floor(Math.random() * (this.gridSize - 10)) + 5;
                const pattern = Math.random() < 0.6 ? block : beehive;
                this.placePattern(this.layer2Grid, pattern, x, y);
            }
        }

        generateCustomShapes() {
            // Create some interesting custom patterns
            const cross = [
                [0, 0, 1, 0, 0],
                [0, 0, 1, 0, 0],
                [1, 1, 1, 1, 1],
                [0, 0, 1, 0, 0],
                [0, 0, 1, 0, 0]
            ];

            const diamond = [
                [0, 0, 1, 0, 0],
                [0, 1, 0, 1, 0],
                [1, 0, 0, 0, 1],
                [0, 1, 0, 1, 0],
                [0, 0, 1, 0, 0]
            ];

            for (let i = 0; i < 3; i++) {
                const x = Math.floor(Math.random() * (this.gridSize - 15)) + 7;
                const y = Math.floor(Math.random() * (this.gridSize - 15)) + 7;
                const pattern = Math.random() < 0.5 ? cross : diamond;
                this.placePattern(this.layer1Grid, pattern, x, y);
            }

            for (let i = 0; i < 4; i++) {
                const x = Math.floor(Math.random() * (this.gridSize - 15)) + 7;
                const y = Math.floor(Math.random() * (this.gridSize - 15)) + 7;
                const pattern = Math.random() < 0.5 ? cross : diamond;
                this.placePattern(this.layer2Grid, pattern, x, y);
            }
        }

        placePattern(grid, pattern, startX, startY) {
            for (let y = 0; y < pattern.length; y++) {
                for (let x = 0; x < pattern[y].length; x++) {
                    const gridX = startX + x;
                    const gridY = startY + y;
                    if (gridX >= 0 && gridX < this.gridSize && gridY >= 0 && gridY < this.gridSize) {
                        grid[gridY][gridX] = pattern[y][x];
                    }
                }
            }
        }

        clearLayer1() {
            for (let y = 0; y < this.gridSize; y++) {
                for (let x = 0; x < this.gridSize; x++) {
                    this.layer1Grid[y][x] = 0;
                }
            }
            this.updateStats();
            this.draw();
        }

        clearLayer2() {
            for (let y = 0; y < this.gridSize; y++) {
                for (let x = 0; x < this.gridSize; x++) {
                    this.layer2Grid[y][x] = 0;
                }
            }
            this.updateStats();
            this.draw();
        }

        randomize() {
            this.layer1Birth = Math.floor(Math.random() * 6) + 1;
            document.getElementById('layer1Birth').value = this.layer1Birth;

            this.layer1SurvivalMin = Math.floor(Math.random() * 4) + 1;
            document.getElementById('layer1SurvivalMin').value = this.layer1SurvivalMin;

            this.layer1SurvivalMax = this.layer1SurvivalMin + Math.floor(Math.random() * 4) + 1;
            document.getElementById('layer1SurvivalMax').value = this.layer1SurvivalMax;

            this.layer2Birth = Math.floor(Math.random() * 8) + 1;
            document.getElementById('layer2Birth').value = this.layer2Birth;

            this.layer2SurvivalMin = Math.floor(Math.random() * 4) + 1;
            document.getElementById('layer2SurvivalMin').value = this.layer2SurvivalMin;

            this.layer2SurvivalMax = this.layer2SurvivalMin + Math.floor(Math.random() * 6) + 1;
            document.getElementById('layer2SurvivalMax').value = this.layer2SurvivalMax;

            this.influenceStrength = Math.random() * 0.8 + 0.1;
            document.getElementById('influenceStrength').value = Math.floor(this.influenceStrength * 100);
            document.getElementById('influenceStrengthValue').textContent = Math.floor(this.influenceStrength * 100) + '%';

            this.layer1StepRatio = Math.floor(Math.random() * 8) + 1;
            document.getElementById('layer1Ratio').value = this.layer1StepRatio;
            document.getElementById('layer1RatioValue').textContent = `1:${this.layer1StepRatio} (Layer1:Layer2)`;

            const modes = ['additive', 'inhibitive', 'catalytic', 'competitive'];
            this.influenceMode = modes[Math.floor(Math.random() * modes.length)];
            document.getElementById('influenceMode').value = this.influenceMode;
        }

        toggleSimulation() {
            this.running = !this.running;
            document.getElementById('startStop').textContent = this.running ? 'Stop' : 'Start';

            if (this.running) {
                this.run();
            }
        }

        run() {
            if (!this.running) return;

            this.step();
            setTimeout(() => this.run(), this.speed);
        }

        step() {
            this.stepCounter++;

            // Update Layer 1 based on step ratio
            if (this.stepCounter % this.layer1StepRatio === 0) {
                this.updateLayer1();
                this.layer1Generation++;
            }

            // Always update Layer 2
            this.updateLayer2();

            this.generation++;
            this.updateStats();
            this.draw();
        }

        updateLayer1() {
            for (let y = 0; y < this.gridSize; y++) {
                for (let x = 0; x < this.gridSize; x++) {
                    const neighbors = this.countNeighbors(this.layer1Grid, x, y, this.layer1Radius);
                    const isAlive = this.layer1Grid[y][x] === 1;

                    if (isAlive) {
                        this.layer1NextGrid[y][x] = (neighbors >= this.layer1SurvivalMin && neighbors <= this.layer1SurvivalMax) ? 1 : 0;
                    } else {
                        this.layer1NextGrid[y][x] = (neighbors === this.layer1Birth) ? 1 : 0;
                    }
                }
            }

            // Swap grids
            [this.layer1Grid, this.layer1NextGrid] = [this.layer1NextGrid, this.layer1Grid];
        }

        updateLayer2() {
            let influenceCount = 0;

            for (let y = 0; y < this.gridSize; y++) {
                for (let x = 0; x < this.gridSize; x++) {
                    let neighbors = this.countNeighbors(this.layer2Grid, x, y, this.layer2Radius);
                    const isAlive = this.layer2Grid[y][x] === 1;
                    const layer1Influence = this.calculateLayer1Influence(x, y);

                    if (layer1Influence > 0) {
                        influenceCount++;
                    }

                    // Apply influence based on mode
                    switch (this.influenceMode) {
                        case 'additive':
                            neighbors += Math.floor(layer1Influence * this.influenceStrength * 8);
                            break;
                        case 'inhibitive':
                            if (layer1Influence > 0.5) {
                                neighbors = Math.max(0, neighbors - Math.floor(this.influenceStrength * 4));
                            }
                            break;
                        case 'catalytic':
                            if (layer1Influence > 0.3 && !isAlive) {
                                neighbors += Math.floor(this.influenceStrength * 6);
                            }
                            break;
                        case 'competitive':
                            if (layer1Influence > 0.7 && Math.random() < this.influenceStrength) {
                                this.layer2NextGrid[y][x] = 0;
                                continue;
                            }
                            break;
                    }

                    if (isAlive) {
                        this.layer2NextGrid[y][x] = (neighbors >= this.layer2SurvivalMin && neighbors <= this.layer2SurvivalMax) ? 1 : 0;
                    } else {
                        this.layer2NextGrid[y][x] = (neighbors === this.layer2Birth) ? 1 : 0;
                    }
                }
            }

            // Swap grids
            [this.layer2Grid, this.layer2NextGrid] = [this.layer2NextGrid, this.layer2Grid];
        }

        calculateLayer1Influence(x, y) {
            let influence = 0;
            const radius = Math.max(this.layer1Radius, this.layer2Radius);

            for (let dy = -radius; dy <= radius; dy++) {
                for (let dx = -radius; dx <= radius; dx++) {
                    const nx = (x + dx + this.gridSize) % this.gridSize;
                    const ny = (y + dy + this.gridSize) % this.gridSize;

                    if (this.layer1Grid[ny][nx] === 1) {
                        const distance = Math.sqrt(dx * dx + dy * dy);
                        influence += Math.max(0, 1 - distance / (radius + 1));
                    }
                }
            }

            return Math.min(1, influence);
        }

        countNeighbors(grid, x, y, radius) {
            let count = 0;

            for (let dy = -radius; dy <= radius; dy++) {
                for (let dx = -radius; dx <= radius; dx++) {
                    if (dx === 0 && dy === 0) continue;

                    const nx = (x + dx + this.gridSize) % this.gridSize;
                    const ny = (y + dy + this.gridSize) % this.gridSize;

                    if (grid[ny][nx] === 1) {
                        count++;
                    }
                }
            }

            return count;
        }

        updateStats() {
            document.getElementById('generation').textContent = this.generation;
            document.getElementById('layer1Generation').textContent = this.layer1Generation;

            let layer1Count = 0;
            let layer2Count = 0;
            let influenceCount = 0;

            for (let y = 0; y < this.gridSize; y++) {
                for (let x = 0; x < this.gridSize; x++) {
                    if (this.layer1Grid[y][x] === 1) layer1Count++;
                    if (this.layer2Grid[y][x] === 1) layer2Count++;
                    if (this.layer1Grid[y][x] === 1 && this.layer2Grid[y][x] === 1) influenceCount++;
                }
            }

            document.getElementById('layer1Cells').textContent = layer1Count;
            document.getElementById('layer2Cells').textContent = layer2Count;
            document.getElementById('totalCells').textContent = layer1Count + layer2Count;
            document.getElementById('influenceCount').textContent = influenceCount;
        }

        draw() {
            // Clear pixel data
            this.pixelData.fill(0);

            // Draw based on display mode
            for (let y = 0; y < this.gridSize; y++) {
                for (let x = 0; x < this.gridSize; x++) {
                    const layer1Active = this.layer1Grid[y][x] === 1;
                    const layer2Active = this.layer2Grid[y][x] === 1;

                    let r = 0, g = 0, b = 0;

                    switch (this.displayMode) {
                        case 'combined':
                            if (layer1Active && layer2Active) {
                                r = 255; g = 255; b = 0; // Yellow for overlap
                            } else if (layer1Active) {
                                r = 255; g = 107; b = 107; // Red for layer 1
                            } else if (layer2Active) {
                                r = 78; g = 205; b = 196; // Cyan for layer 2
                            }
                            break;
                        case 'layer1':
                            if (layer1Active) {
                                r = 255; g = 107; b = 107;
                            }
                            break;
                        case 'layer2':
                            if (layer2Active) {
                                r = 78; g = 205; b = 196;
                            }
                            break;
                        case 'difference':
                            if (layer1Active && !layer2Active) {
                                r = 255; g = 0; b = 0; // Red for layer 1 only
                            } else if (!layer1Active && layer2Active) {
                                r = 0; g = 255; b = 255; // Cyan for layer 2 only
                            } else if (layer1Active && layer2Active) {
                                r = 128; g = 128; b = 128; // Gray for both
                            }
                            break;
                    }

                    if (r > 0 || g > 0 || b > 0) {
                        for (let py = 0; py < this.cellSize; py++) {
                            for (let px = 0; px < this.cellSize; px++) {
                                const pixelX = x * this.cellSize + px;
                                const pixelY = y * this.cellSize + py;
                                const index = (pixelY * this.canvas.width + pixelX) * 4;

                                this.pixelData[index] = r;     // R
                                this.pixelData[index + 1] = g; // G
                                this.pixelData[index + 2] = b; // B
                                this.pixelData[index + 3] = 255; // A
                            }
                        }
                    }
                }
            }

            // Put the image data to canvas
            this.ctx.putImageData(this.imageData, 0, 0);
        }
    }

    new DualLayerGameOfLife();
</script>
</body>
</html>