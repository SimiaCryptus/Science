<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Dual Layer Conway's Life with Ant Interaction</title>
    <style>
        body {
            margin: 0;
            padding: 20px;
            background: linear-gradient(135deg, #0f0f23, #1a1a2e);
            color: #e0e0e0;
            font-family: 'Courier New', monospace;
            min-height: 100vh;
            overflow-x: auto;
        }

        .container {
            max-width: 1800px;
            margin: 0 auto;
            padding: 0 10px;
        }

        h1 {
            text-align: center;
            color: #00ff88;
            text-shadow: 0 0 10px rgba(0, 255, 136, 0.3);
            margin-bottom: 30px;
        }

        .controls {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 20px;
            margin-bottom: 30px;
            padding: 20px;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 15px;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(0, 255, 136, 0.1);
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
        }

        .control-group {
            display: flex;
            flex-direction: column;
            gap: 10px;
            padding: 15px;
            background: rgba(255, 255, 255, 0.03);
            border-radius: 10px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            transition: all 0.3s ease;
        }

        .control-group:hover {
            background: rgba(255, 255, 255, 0.05);
            border-color: rgba(0, 255, 136, 0.3);
            transform: translateY(-2px);
            box-shadow: 0 4px 15px rgba(0, 255, 136, 0.1);
        }

        .control-group label {
            color: #00ff88;
            font-weight: bold;
            font-size: 13px;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            margin-bottom: 5px;
        }

        .binary-display {
            font-family: 'Courier New', monospace;
            font-size: 18px;
            color: #00ff88;
            background: rgba(0, 0, 0, 0.3);
            padding: 12px;
            border-radius: 5px;
            text-align: center;
            border: 2px solid #333;
            font-weight: bold;
            letter-spacing: 2px;
            text-shadow: 0 0 5px rgba(0, 255, 136, 0.3);
        }

        .layer-controls {
            border: 2px solid rgba(0, 255, 136, 0.3);
            border-radius: 10px;
            padding: 15px;
            margin-bottom: 10px;
            background: rgba(0, 255, 136, 0.05);
        }

        .layer-title {
            color: #00ff88;
            font-weight: bold;
            font-size: 16px;
            margin-bottom: 15px;
            text-align: center;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .rule-editor {
            display: flex;
            flex-direction: column;
            gap: 10px;
        }

        .rule-row {
            display: flex;
            align-items: center;
            gap: 10px;
            font-size: 14px;
            padding: 8px;
            background: rgba(0, 0, 0, 0.2);
            border-radius: 5px;
            margin-bottom: 5px;
            transition: all 0.3s ease;
        }

        .rule-row:hover {
            background: rgba(0, 0, 0, 0.3);
            border: 1px solid rgba(0, 255, 136, 0.2);
        }

        .rule-bit {
            width: 20px;
            height: 20px;
            background: #333;
            border: 1px solid #666;
            border-radius: 3px;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            transition: all 0.2s ease;
            font-weight: bold;
            font-size: 12px;
        }

        .rule-bit.active {
            background: #00ff88;
            color: #000;
            box-shadow: 0 0 10px rgba(0, 255, 136, 0.5);
            border-color: #00ff88;
        }

        .rule-bit:hover {
            border-color: #00ff88;
            transform: scale(1.1);
        }

        input[type="range"] {
            width: 100%;
            height: 8px;
            border-radius: 4px;
            background: #333;
            outline: none;
            -webkit-appearance: none;
        }

        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: #00ff88;
            cursor: pointer;
            box-shadow: 0 0 10px rgba(0, 255, 136, 0.5);
        }

        input[type="range"]::-moz-range-thumb {
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: #00ff88;
            cursor: pointer;
            border: none;
            box-shadow: 0 0 10px rgba(0, 255, 136, 0.5);
        }

        select, input[type="number"], input[type="text"] {
            padding: 8px;
            border-radius: 8px;
            border: 1px solid #444;
            background: rgba(0, 0, 0, 0.3);
            color: #e0e0e0;
            font-family: inherit;
            transition: all 0.3s ease;
        }

        select:focus, input[type="number"]:focus, input[type="text"]:focus {
            outline: none;
            border-color: #00ff88;
            box-shadow: 0 0 10px rgba(0, 255, 136, 0.3);
        }

        .buttons {
            display: flex;
            gap: 15px;
            flex-wrap: wrap;
            justify-content: center;
            margin-bottom: 20px;
            padding: 20px;
            background: rgba(255, 255, 255, 0.03);
            border-radius: 15px;
            border: 1px solid rgba(255, 255, 255, 0.1);
        }

        button {
            padding: 12px 24px;
            border: none;
            border-radius: 25px;
            background: linear-gradient(45deg, #00ff88, #00cc6a);
            color: #000;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s ease;
            font-family: inherit;
            box-shadow: 0 4px 15px rgba(0, 255, 136, 0.3);
        }

        button:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(0, 255, 136, 0.4);
        }

        button:active {
            transform: translateY(0);
        }

        button.secondary {
            background: linear-gradient(45deg, #666, #888);
            color: #fff;
            box-shadow: 0 4px 15px rgba(255, 255, 255, 0.1);
        }

        button.secondary:hover {
            box-shadow: 0 6px 20px rgba(255, 255, 255, 0.2);
        }

        .canvas-container {
            display: flex;
            justify-content: center;
            margin-bottom: 20px;
            padding: 20px;
            background: rgba(255, 255, 255, 0.03);
            border-radius: 15px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            transition: all 0.5s ease;
            position: relative;
        }

        .canvas-container.zoomed {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            margin: 0;
            padding: 20px;
            background: rgba(0, 0, 0, 0.95);
            border-radius: 0;
            z-index: 1000;
            backdrop-filter: blur(10px);
        }

        canvas {
            border: 2px solid #00ff88;
            border-radius: 10px;
            background: #000;
            box-shadow: 0 0 40px rgba(0, 255, 136, 0.4), inset 0 0 20px rgba(0, 0, 0, 0.5);
            transition: all 0.3s ease;
            cursor: pointer;
        }

        canvas:hover {
            box-shadow: 0 0 50px rgba(0, 255, 136, 0.6), inset 0 0 20px rgba(0, 0, 0, 0.5);
            transform: scale(1.02);
        }

        .canvas-container.zoomed canvas {
            max-width: calc(100vw - 40px);
            max-height: calc(100vh - 40px);
            width: auto;
            height: auto;
            transform: none;
        }

        .canvas-container.zoomed canvas:hover {
            transform: none;
        }

        .zoom-hint {
            position: absolute;
            top: 10px;
            right: 10px;
            background: rgba(0, 255, 136, 0.2);
            color: #00ff88;
            padding: 8px 12px;
            border-radius: 20px;
            font-size: 12px;
            opacity: 0;
            transition: opacity 0.3s ease;
            pointer-events: none;
            backdrop-filter: blur(5px);
            border: 1px solid rgba(0, 255, 136, 0.3);
        }

        .canvas-container:hover .zoom-hint {
            opacity: 1;
        }

        .canvas-container.zoomed .zoom-hint {
            opacity: 1;
            background: rgba(255, 255, 255, 0.2);
            color: #fff;
        }

        .stats {
            text-align: center;
            font-size: 14px;
            color: #888;
            display: flex;
            justify-content: center;
            gap: 30px;
            flex-wrap: wrap;
            padding: 20px;
            background: rgba(255, 255, 255, 0.03);
            border-radius: 15px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            margin-bottom: 20px;
        }

        .stat {
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 15px;
            background: rgba(0, 0, 0, 0.2);
            border-radius: 10px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            transition: all 0.3s ease;
            min-width: 80px;
        }

        .stat:hover {
            background: rgba(0, 0, 0, 0.3);
            border-color: rgba(0, 255, 136, 0.3);
            transform: translateY(-2px);
        }

        .stat-value {
            color: #00ff88;
            font-weight: bold;
            font-size: 24px;
            text-shadow: 0 0 10px rgba(0, 255, 136, 0.5);
            margin-bottom: 5px;
        }

        .stat-label {
            font-size: 12px;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            color: #aaa;
        }

        .layer-stats {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
            margin-bottom: 20px;
        }

        .layer-stat-group {
            padding: 15px;
            background: rgba(255, 255, 255, 0.03);
            border-radius: 15px;
            border: 1px solid rgba(255, 255, 255, 0.1);
        }

        .layer-stat-title {
            color: #00ff88;
            font-weight: bold;
            text-align: center;
            margin-bottom: 15px;
            font-size: 16px;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .layer-stat-row {
            display: flex;
            justify-content: space-between;
            margin-bottom: 10px;
            padding: 8px;
            background: rgba(0, 0, 0, 0.2);
            border-radius: 5px;
        }

        .info {
            margin-top: 20px;
            padding: 20px;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 15px;
            backdrop-filter: blur(10px);
            font-size: 14px;
            line-height: 1.6;
            border: 1px solid rgba(0, 255, 136, 0.1);
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
        }

        .info h3 {
            color: #00ff88;
            margin-top: 0;
            text-shadow: 0 0 10px rgba(0, 255, 136, 0.3);
            border-bottom: 2px solid rgba(0, 255, 136, 0.3);
            padding-bottom: 10px;
            margin-bottom: 20px;
        }

        .info p {
            margin-bottom: 15px;
        }

        .info strong {
            color: #00ff88;
            text-shadow: 0 0 5px rgba(0, 255, 136, 0.3);
        }

        /* Enhanced visual effects */
        .container::before {
            content: '';
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: radial-gradient(circle at 20% 50%, rgba(0, 255, 136, 0.1) 0%, transparent 50%),
            radial-gradient(circle at 80% 20%, rgba(0, 255, 136, 0.05) 0%, transparent 50%),
            radial-gradient(circle at 40% 80%, rgba(0, 255, 136, 0.03) 0%, transparent 50%);
            pointer-events: none;
            z-index: -1;
        }

        /* Responsive design */
        @media (max-width: 1200px) {
            .controls {
                grid-template-columns: repeat(auto-fit, minmax(220px, 1fr));
                gap: 15px;
                padding: 15px;
            }

            .layer-stats {
                grid-template-columns: 1fr;
            }
        }

        @media (max-width: 768px) {
            body {
                padding: 10px;
            }

            .controls {
                grid-template-columns: 1fr;
                gap: 10px;
                padding: 10px;
            }

            .buttons {
                flex-direction: column;
                align-items: center;
            }

            button {
                width: 200px;
            }

            .stats {
                flex-direction: column;
                gap: 10px;
            }

            .stat {
                width: 100%;
                max-width: 200px;
                margin: 0 auto;
            }
        }
    </style>
</head>
<body>
<div class="container">
    <h1>Dual Layer Conway's Life with Ant Interaction</h1>

    <div class="controls">
        <div class="control-group">
            <label>Simulation Speed</label>
            <input type="range" id="speed" min="1" max="2000" value="100">
            <span id="speedValue">100 ms</span>
        </div>

        <div class="control-group">
            <label>Step Ratio (Fast:Slow)</label>
            <input type="range" id="stepRatio" min="1" max="20" value="5">
            <span id="stepRatioValue">5:1</span>
        </div>

        <div class="control-group">
            <label>Number of Ants</label>
            <input type="range" id="numAnts" min="1" max="8" value="2">
            <span id="numAntsValue">2</span>
        </div>

        <div class="control-group">
            <label>Ant Spawn Mode</label>
            <select id="antSpawnMode">
                <option value="center">Center</option>
                <option value="corners">Corners</option>
                <option value="edges">Edges</option>
                <option value="random">Random</option>
                <option value="grid">Grid Pattern</option>
            </select>
        </div>

        <div class="control-group">
            <label>Ant Rule (Binary: L=0, R=1)</label>
            <div class="binary-display" id="antRuleDisplay">0101</div>
            <div class="rule-editor" id="antRuleEditor"></div>
        </div>

        <div class="control-group">
            <label>Layer Interaction Mode</label>
            <select id="interactionMode">
                <option value="seeding">Ant Seeding</option>
                <option value="inhibition">Layer Inhibition</option>
                <option value="activation">Cross Activation</option>
                <option value="competition">Competition</option>
            </select>
        </div>

        <div class="control-group">
            <div class="layer-controls">
                <div class="layer-title">Fast Layer (Green)</div>
                <label>Birth Rule</label>
                <input type="number" id="fastBirth" min="1" max="8" value="3">
                <label>Survival Min/Max</label>
                <div style="display: flex; gap: 10px;">
                    <input type="number" id="fastSurvivalMin" min="1" max="8" value="2">
                    <input type="number" id="fastSurvivalMax" min="1" max="8" value="3">
                </div>
            </div>
        </div>

        <div class="control-group">
            <div class="layer-controls">
                <div class="layer-title">Slow Layer (Blue)</div>
                <label>Birth Rule</label>
                <input type="number" id="slowBirth" min="1" max="8" value="3">
                <label>Survival Min/Max</label>
                <div style="display: flex; gap: 10px;">
                    <input type="number" id="slowSurvivalMin" min="1" max="8" value="2">
                    <input type="number" id="slowSurvivalMax" min="1" max="8" value="3">
                </div>
            </div>
        </div>

        <div class="control-group">
            <label>Ant Activation Radius</label>
            <input type="range" id="antActivationRadius" min="1" max="8" value="3">
            <span id="antRadiusValue">3</span>
        </div>

        <div class="control-group">
            <label>Activation Probability</label>
            <input type="range" id="activationProbability" min="0" max="100" value="30">
            <span id="activationProbValue">30%</span>
        </div>

        <div class="control-group">
            <label>Grid Size</label>
            <select id="gridSize">
                <option value="50">50x50</option>
                <option value="75">75x75</option>
                <option value="100">100x100</option>
                <option value="125">125x125</option>
                <option value="150" selected>150x150</option>
                <option value="200">200x200</option>
                <option value="250">250x250</option>
                <option value="300">300x300</option>
            </select>
        </div>
    </div>

    <div class="buttons">
        <button id="startStop">Start</button>
        <button id="step" class="secondary">Step</button>
        <button id="reset" class="secondary">Reset</button>
        <button id="randomize">Randomize All</button>
        <button id="seedRandom" class="secondary">Seed Random Life</button>
        <button id="clearLayers" class="secondary">Clear Layers</button>
    </div>

    <div class="canvas-container">
        <canvas id="canvas" width="600" height="600"></canvas>
        <div class="zoom-hint">Click to zoom</div>
    </div>

    <div class="stats">
        <div class="stat">
            <div class="stat-value" id="generation">0</div>
            <div class="stat-label">Generation</div>
        </div>
        <div class="stat">
            <div class="stat-value" id="antSteps">0</div>
            <div class="stat-label">Ant Steps</div>
        </div>
        <div class="stat">
            <div class="stat-value" id="numAntsDisplay">2</div>
            <div class="stat-label">Active Ants</div>
        </div>
        <div class="stat">
            <div class="stat-value" id="stepRatioDisplay">5:1</div>
            <div class="stat-label">Step Ratio</div>
        </div>
    </div>

    <div class="layer-stats">
        <div class="layer-stat-group">
            <div class="layer-stat-title">Fast Layer</div>
            <div class="layer-stat-row">
                <span>Live Cells:</span>
                <span id="fastLiveCells">0</span>
            </div>
            <div class="layer-stat-row">
                <span>Steps:</span>
                <span id="fastSteps">0</span>
            </div>
            <div class="layer-stat-row">
                <span>Birth/Survival:</span>
                <span id="fastRules">3/2-3</span>
            </div>
        </div>
        <div class="layer-stat-group">
            <div class="layer-stat-title">Slow Layer</div>
            <div class="layer-stat-row">
                <span>Live Cells:</span>
                <span id="slowLiveCells">0</span>
            </div>
            <div class="layer-stat-row">
                <span>Steps:</span>
                <span id="slowSteps">0</span>
            </div>
            <div class="layer-stat-row">
                <span>Birth/Survival:</span>
                <span id="slowRules">3/2-3</span>
            </div>
        </div>
    </div>

    <div class="info">
        <h3>Dual Layer Conway's Life System</h3>
        <p><strong>Two-Layer Architecture:</strong> The system runs two independent Conway's Game of Life layers - a fast layer (green) and a slow layer (blue) that evolve at different timescales controlled by the step ratio.</p>
        <p><strong>Temporal Dynamics:</strong> The step ratio determines how many fast layer generations occur for each slow layer generation. This creates interesting temporal patterns where fast dynamics can stabilize before slow dynamics respond.</p>
        <p><strong>Ant Interaction:</strong> Ants move on a binary substrate using Langton's Ant rules and can seed life in both layers simultaneously. Different interaction modes control how the layers influence each other.</p>
        <p><strong>Layer Interaction Modes:</strong></p>
        <ul>
            <li><strong>Ant Seeding:</strong> Ants seed life in both layers independently</li>
            <li><strong>Layer Inhibition:</strong> Life in one layer prevents life in the other at the same location</li>
            <li><strong>Cross Activation:</strong> Life in one layer can seed life in the other layer</li>
            <li><strong>Competition:</strong> Layers compete for space, with random winner selection</li>
        </ul>
        <p><strong>Emergent Complexity:</strong> The interaction between different timescales, ant movement patterns, and layer interactions creates rich emergent behaviors including stable oscillators, traveling patterns, and complex ecological dynamics between the layers.</p>
    </div>
</div>

<script>
    class DualLayerConway {
        constructor() {
            this.canvas = document.getElementById('canvas');
            this.ctx = this.canvas.getContext('2d');
            this.imageData = null;
            this.pixelData = null;
            this.gridSize = 150;
            this.cellSize = 4;
            this.running = false;
            this.generation = 0;
            this.isZoomed = false;

            // Dual layer system
            this.fastLayer = [];
            this.slowLayer = [];
            this.fastSteps = 0;
            this.slowSteps = 0;
            this.stepRatio = 5;
            this.stepCounter = 0;

            // Layer rules
            this.fastBirth = 3;
            this.fastSurvivalMin = 2;
            this.fastSurvivalMax = 3;
            this.slowBirth = 3;
            this.slowSurvivalMin = 2;
            this.slowSurvivalMax = 3;

            // Ant system
            this.numAnts = 2;
            this.antSpawnMode = 'center';
            this.ants = [];
            this.antRule = [0, 1, 0, 1];
            this.substrateGrid = [];

            // Interaction parameters
            this.interactionMode = 'seeding';
            this.antActivationRadius = 3;
            this.activationProbability = 0.3;
            this.speed = 100;

            this.setupEventListeners();
            this.updateCanvasSize();
            this.updateRuleEditor();
            this.initializeAnts();
            this.reset();
        }

        setupEventListeners() {
            document.getElementById('startStop').addEventListener('click', () => this.toggleSimulation());
            document.getElementById('step').addEventListener('click', () => this.step());
            document.getElementById('reset').addEventListener('click', () => this.reset());
            document.getElementById('randomize').addEventListener('click', () => this.randomize());
            document.getElementById('seedRandom').addEventListener('click', () => this.seedRandomLife());
            document.getElementById('clearLayers').addEventListener('click', () => this.clearLayers());

            // Canvas zoom functionality
            this.canvas.addEventListener('click', (e) => {
                e.preventDefault();
                this.toggleZoom();
            });

            document.addEventListener('keydown', (e) => {
                if (e.key === 'Escape' && this.isZoomed) {
                    this.toggleZoom();
                }
            });

            window.addEventListener('resize', () => {
                if (this.isZoomed) {
                    this.updateZoomedCanvasSize();
                }
            });

            document.getElementById('speed').addEventListener('input', (e) => {
                this.speed = parseInt(e.target.value);
                const speedText = this.speed >= 1000 ?
                    (this.speed / 1000).toFixed(1) + ' s' :
                    this.speed + ' ms';
                document.getElementById('speedValue').textContent = speedText;
            });

            document.getElementById('stepRatio').addEventListener('input', (e) => {
                this.stepRatio = parseInt(e.target.value);
                document.getElementById('stepRatioValue').textContent = this.stepRatio + ':1';
                document.getElementById('stepRatioDisplay').textContent = this.stepRatio + ':1';
            });

            document.getElementById('numAnts').addEventListener('input', (e) => {
                this.numAnts = parseInt(e.target.value);
                document.getElementById('numAntsValue').textContent = this.numAnts;
                document.getElementById('numAntsDisplay').textContent = this.numAnts;
                this.initializeAnts();
            });

            document.getElementById('antSpawnMode').addEventListener('change', (e) => {
                this.antSpawnMode = e.target.value;
                this.initializeAnts();
            });

            document.getElementById('interactionMode').addEventListener('change', (e) => {
                this.interactionMode = e.target.value;
            });

            document.getElementById('antActivationRadius').addEventListener('input', (e) => {
                this.antActivationRadius = parseInt(e.target.value);
                document.getElementById('antRadiusValue').textContent = this.antActivationRadius;
            });

            document.getElementById('activationProbability').addEventListener('input', (e) => {
                this.activationProbability = parseInt(e.target.value) / 100;
                document.getElementById('activationProbValue').textContent = parseInt(e.target.value) + '%';
            });

            document.getElementById('gridSize').addEventListener('change', (e) => {
                this.gridSize = parseInt(e.target.value);
                this.updateCanvasSize();
                this.initializeAnts();
                this.reset();
            });

            // Layer rule controls
            ['fastBirth', 'fastSurvivalMin', 'fastSurvivalMax', 'slowBirth', 'slowSurvivalMin', 'slowSurvivalMax'].forEach(id => {
                document.getElementById(id).addEventListener('input', (e) => {
                    this[id] = parseInt(e.target.value);
                    this.updateLayerRuleDisplay();
                });
            });
        }

        updateLayerRuleDisplay() {
            document.getElementById('fastRules').textContent = `${this.fastBirth}/${this.fastSurvivalMin}-${this.fastSurvivalMax}`;
            document.getElementById('slowRules').textContent = `${this.slowBirth}/${this.slowSurvivalMin}-${this.slowSurvivalMax}`;
        }

        initializeAnts() {
            this.ants = [];
            const positions = this.getAntSpawnPositions();

            for (let i = 0; i < this.numAnts; i++) {
                const ant = {
                    id: i,
                    x: positions[i].x,
                    y: positions[i].y,
                    dir: Math.floor(Math.random() * 4),
                    steps: 0,
                    color: this.getAntColor(i)
                };
                this.ants.push(ant);
            }
        }

        getAntSpawnPositions() {
            const positions = [];
            const centerX = Math.floor(this.gridSize / 2);
            const centerY = Math.floor(this.gridSize / 2);

            switch (this.antSpawnMode) {
                case 'center':
                    for (let i = 0; i < this.numAnts; i++) {
                        const angle = (i / this.numAnts) * 2 * Math.PI;
                        const radius = Math.min(5, i * 2);
                        positions.push({
                            x: Math.floor(centerX + Math.cos(angle) * radius),
                            y: Math.floor(centerY + Math.sin(angle) * radius)
                        });
                    }
                    break;

                case 'corners':
                    const corners = [
                        {x: 10, y: 10},
                        {x: this.gridSize - 10, y: 10},
                        {x: this.gridSize - 10, y: this.gridSize - 10},
                        {x: 10, y: this.gridSize - 10},
                        {x: centerX, y: 10},
                        {x: this.gridSize - 10, y: centerY},
                        {x: centerX, y: this.gridSize - 10},
                        {x: 10, y: centerY}
                    ];
                    for (let i = 0; i < this.numAnts; i++) {
                        positions.push(corners[i % corners.length]);
                    }
                    break;

                case 'edges':
                    for (let i = 0; i < this.numAnts; i++) {
                        const edge = i % 4;
                        const progress = (i / this.numAnts) * 0.8 + 0.1;
                        switch (edge) {
                            case 0:
                                positions.push({x: Math.floor(this.gridSize * progress), y: 10});
                                break;
                            case 1:
                                positions.push({x: this.gridSize - 10, y: Math.floor(this.gridSize * progress)});
                                break;
                            case 2:
                                positions.push({x: Math.floor(this.gridSize * (1 - progress)), y: this.gridSize - 10});
                                break;
                            case 3:
                                positions.push({x: 10, y: Math.floor(this.gridSize * (1 - progress))});
                                break;
                        }
                    }
                    break;

                case 'grid':
                    const gridSize = Math.ceil(Math.sqrt(this.numAnts));
                    const spacing = Math.floor(this.gridSize / (gridSize + 1));
                    for (let i = 0; i < this.numAnts; i++) {
                        const row = Math.floor(i / gridSize);
                        const col = i % gridSize;
                        positions.push({
                            x: spacing * (col + 1),
                            y: spacing * (row + 1)
                        });
                    }
                    break;

                case 'random':
                default:
                    for (let i = 0; i < this.numAnts; i++) {
                        positions.push({
                            x: Math.floor(Math.random() * (this.gridSize - 20)) + 10,
                            y: Math.floor(Math.random() * (this.gridSize - 20)) + 10
                        });
                    }
                    break;
            }

            return positions;
        }

        getAntColor(index) {
            const colors = ['#ff3333', '#33ff33', '#3333ff', '#ffff33', '#ff33ff', '#33ffff', '#ff8833', '#8833ff'];
            return colors[index % colors.length];
        }

        updateRuleEditor() {
            const editor = document.getElementById('antRuleEditor');
            editor.innerHTML = '';

            for (let i = 0; i < 4; i++) {
                const row = document.createElement('div');
                row.className = 'rule-row';

                const colorIndicator = document.createElement('div');
                colorIndicator.style.width = '20px';
                colorIndicator.style.height = '20px';
                colorIndicator.style.backgroundColor = i === 0 ? '#000000' : '#ffffff';
                colorIndicator.style.border = '1px solid #666';
                colorIndicator.style.borderRadius = '3px';

                const bit = document.createElement('div');
                bit.className = `rule-bit ${this.antRule[i] ? 'active' : ''}`;
                bit.textContent = this.antRule[i];
                bit.addEventListener('click', () => {
                    this.antRule[i] = 1 - this.antRule[i];
                    bit.textContent = this.antRule[i];
                    bit.className = `rule-bit ${this.antRule[i] ? 'active' : ''}`;
                    this.updateRuleDisplay();
                    label.textContent = `State ${i}: ${this.antRule[i] ? 'Right' : 'Left'}`;
                });

                const label = document.createElement('span');
                label.textContent = `State ${i}: ${this.antRule[i] ? 'Right' : 'Left'}`;

                row.appendChild(colorIndicator);
                row.appendChild(bit);
                row.appendChild(label);
                editor.appendChild(row);
            }
        }

        updateRuleDisplay() {
            document.getElementById('antRuleDisplay').textContent = this.antRule.join('');
        }

        updateCanvasSize() {
            if (this.isZoomed) {
                this.updateZoomedCanvasSize();
            } else {
                this.updateNormalCanvasSize();
            }
        }

        updateNormalCanvasSize() {
            const maxCanvasSize = Math.min(window.innerWidth * 0.8, window.innerHeight * 0.6, 800);
            this.cellSize = Math.max(1, Math.floor(maxCanvasSize / this.gridSize));
            const actualCanvasSize = this.gridSize * this.cellSize;
            this.canvas.width = actualCanvasSize;
            this.canvas.height = actualCanvasSize;
            this.imageData = this.ctx.createImageData(actualCanvasSize, actualCanvasSize);
            this.pixelData = this.imageData.data;
        }

        updateZoomedCanvasSize() {
            const maxWidth = window.innerWidth - 40;
            const maxHeight = window.innerHeight - 40;
            const maxCanvasSize = Math.min(maxWidth, maxHeight);
            this.cellSize = Math.max(1, Math.floor(maxCanvasSize / this.gridSize));
            const actualCanvasSize = this.gridSize * this.cellSize;
            this.canvas.width = actualCanvasSize;
            this.canvas.height = actualCanvasSize;
            this.imageData = this.ctx.createImageData(actualCanvasSize, actualCanvasSize);
            this.pixelData = this.imageData.data;
        }

        toggleZoom() {
            this.isZoomed = !this.isZoomed;
            const container = document.querySelector('.canvas-container');
            const hint = document.querySelector('.zoom-hint');

            if (this.isZoomed) {
                container.classList.add('zoomed');
                hint.textContent = 'Click or press ESC to exit zoom';
                document.body.style.overflow = 'hidden';
                this.updateZoomedCanvasSize();
            } else {
                container.classList.remove('zoomed');
                hint.textContent = 'Click to zoom';
                document.body.style.overflow = '';
                this.updateNormalCanvasSize();
            }

            this.draw();
        }

        reset() {
            this.running = false;
            this.generation = 0;
            this.fastSteps = 0;
            this.slowSteps = 0;
            this.stepCounter = 0;

            this.initializeAnts();

            // Initialize grids
            this.substrateGrid = new Array(this.gridSize).fill(null).map(() => new Array(this.gridSize).fill(0));
            this.fastLayer = new Array(this.gridSize).fill(null).map(() => new Array(this.gridSize).fill(0));
            this.slowLayer = new Array(this.gridSize).fill(null).map(() => new Array(this.gridSize).fill(0));

            document.getElementById('startStop').textContent = 'Start';
            this.updateStats();
            this.draw();
        }

        randomize() {
            // Randomize ant rule
            for (let i = 0; i < 4; i++) {
                this.antRule[i] = Math.floor(Math.random() * 2);
            }
            this.updateRuleEditor();
            this.updateRuleDisplay();

            // Randomize layer rules
            this.fastBirth = Math.floor(Math.random() * 8) + 1;
            this.fastSurvivalMin = Math.floor(Math.random() * 4) + 1;
            this.fastSurvivalMax = this.fastSurvivalMin + Math.floor(Math.random() * (8 - this.fastSurvivalMin));

            this.slowBirth = Math.floor(Math.random() * 8) + 1;
            this.slowSurvivalMin = Math.floor(Math.random() * 4) + 1;
            this.slowSurvivalMax = this.slowSurvivalMin + Math.floor(Math.random() * (8 - this.slowSurvivalMin));

            // Update UI
            document.getElementById('fastBirth').value = this.fastBirth;
            document.getElementById('fastSurvivalMin').value = this.fastSurvivalMin;
            document.getElementById('fastSurvivalMax').value = this.fastSurvivalMax;
            document.getElementById('slowBirth').value = this.slowBirth;
            document.getElementById('slowSurvivalMin').value = this.slowSurvivalMin;
            document.getElementById('slowSurvivalMax').value = this.slowSurvivalMax;

            this.updateLayerRuleDisplay();

            // Randomize other parameters
            this.stepRatio = Math.floor(Math.random() * 15) + 1;
            document.getElementById('stepRatio').value = this.stepRatio;
            document.getElementById('stepRatioValue').textContent = this.stepRatio + ':1';
            document.getElementById('stepRatioDisplay').textContent = this.stepRatio + ':1';

            this.antActivationRadius = Math.floor(Math.random() * 6) + 1;
            document.getElementById('antActivationRadius').value = this.antActivationRadius;
            document.getElementById('antRadiusValue').textContent = this.antActivationRadius;

            this.activationProbability = Math.random() * 0.8 + 0.1;
            document.getElementById('activationProbability').value = Math.floor(this.activationProbability * 100);
            document.getElementById('activationProbValue').textContent = Math.floor(this.activationProbability * 100) + '%';

            this.initializeAnts();
        }

        seedRandomLife() {
            const density = 0.1;
            for (let y = 0; y < this.gridSize; y++) {
                for (let x = 0; x < this.gridSize; x++) {
                    if (Math.random() < density) {
                        if (Math.random() < 0.5) {
                            this.fastLayer[y][x] = 1;
                        } else {
                            this.slowLayer[y][x] = 1;
                        }
                    }
                }
            }
            this.draw();
        }

        clearLayers() {
            for (let y = 0; y < this.gridSize; y++) {
                for (let x = 0; x < this.gridSize; x++) {
                    this.fastLayer[y][x] = 0;
                    this.slowLayer[y][x] = 0;
                }
            }
            this.draw();
        }

        toggleSimulation() {
            this.running = !this.running;
            document.getElementById('startStop').textContent = this.running ? 'Stop' : 'Start';

            if (this.running) {
                this.run();
            }
        }

        run() {
            if (!this.running) return;

            this.step();
            setTimeout(() => this.run(), this.speed);
        }

        step() {
            // Move ants
            this.moveAllAnts();

            // Update fast layer every step
            this.updateLayer(this.fastLayer, this.fastBirth, this.fastSurvivalMin, this.fastSurvivalMax);
            this.fastSteps++;

            // Update slow layer based on step ratio
            this.stepCounter++;
            if (this.stepCounter >= this.stepRatio) {
                this.updateLayer(this.slowLayer, this.slowBirth, this.slowSurvivalMin, this.slowSurvivalMax);
                this.slowSteps++;
                this.stepCounter = 0;
            }

            // Apply layer interactions
            this.applyLayerInteractions();

            this.generation++;
            this.updateStats();
            this.draw();
        }

        moveAllAnts() {
            for (let ant of this.ants) {
                this.moveAnt(ant);
            }
        }

        moveAnt(ant) {
            const currentState = this.substrateGrid[ant.y][ant.x];
            const turnRight = this.antRule[currentState % 4];

            if (turnRight) {
                ant.dir = (ant.dir + 1) % 4;
            } else {
                ant.dir = (ant.dir + 3) % 4;
            }

            // Flip substrate state
            this.substrateGrid[ant.y][ant.x] = 1 - this.substrateGrid[ant.y][ant.x];

            // Seed life around ant
            this.seedLifeAroundAnt(ant);

            // Move ant
            const dx = [0, 1, 0, -1][ant.dir];
            const dy = [-1, 0, 1, 0][ant.dir];

            ant.x = (ant.x + dx + this.gridSize) % this.gridSize;
            ant.y = (ant.y + dy + this.gridSize) % this.gridSize;

            ant.steps++;
        }

        seedLifeAroundAnt(ant) {
            const radius = this.antActivationRadius;
            const radiusSquared = radius * radius;

            for (let dy = -radius; dy <= radius; dy++) {
                for (let dx = -radius; dx <= radius; dx++) {
                    if (dx === 0 && dy === 0) continue;

                    const distanceSquared = dx * dx + dy * dy;
                    if (distanceSquared > radiusSquared) continue;

                    const nx = (ant.x + dx + this.gridSize) % this.gridSize;
                    const ny = (ant.y + dy + this.gridSize) % this.gridSize;

                    const distance = Math.sqrt(distanceSquared);
                    const activationChance = Math.max(0, 1 - (distance / (radius + 1)));

                    if (Math.random() < activationChance * this.activationProbability) {
                        // Seed in both layers based on interaction mode
                        if (this.interactionMode === 'seeding') {
                            if (Math.random() < 0.5) {
                                this.fastLayer[ny][nx] = 1;
                            } else {
                                this.slowLayer[ny][nx] = 1;
                            }
                        }
                    }
                }
            }
        }

        updateLayer(layer, birth, survivalMin, survivalMax) {
            const newLayer = new Array(this.gridSize).fill(null).map(() => new Array(this.gridSize).fill(0));

            for (let y = 0; y < this.gridSize; y++) {
                for (let x = 0; x < this.gridSize; x++) {
                    const neighbors = this.countNeighbors(layer, x, y);
                    const isAlive = layer[y][x] === 1;

                    if (isAlive) {
                        if (neighbors >= survivalMin && neighbors <= survivalMax) {
                            newLayer[y][x] = 1;
                        }
                    } else {
                        if (neighbors === birth) {
                            newLayer[y][x] = 1;
                        }
                    }
                }
            }

            // Copy new layer back
            for (let y = 0; y < this.gridSize; y++) {
                for (let x = 0; x < this.gridSize; x++) {
                    layer[y][x] = newLayer[y][x];
                }
            }
        }

        countNeighbors(layer, x, y) {
            let count = 0;
            for (let dy = -1; dy <= 1; dy++) {
                for (let dx = -1; dx <= 1; dx++) {
                    if (dx === 0 && dy === 0) continue;

                    const nx = (x + dx + this.gridSize) % this.gridSize;
                    const ny = (y + dy + this.gridSize) % this.gridSize;

                    if (layer[ny][nx] === 1) {
                        count++;
                    }
                }
            }
            return count;
        }

        applyLayerInteractions() {
            switch (this.interactionMode) {
                case 'inhibition':
                    for (let y = 0; y < this.gridSize; y++) {
                        for (let x = 0; x < this.gridSize; x++) {
                            if (this.fastLayer[y][x] === 1 && this.slowLayer[y][x] === 1) {
                                if (Math.random() < 0.5) {
                                    this.fastLayer[y][x] = 0;
                                } else {
                                    this.slowLayer[y][x] = 0;
                                }
                            }
                        }
                    }
                    break;

                case 'activation':
                    for (let y = 0; y < this.gridSize; y++) {
                        for (let x = 0; x < this.gridSize; x++) {
                            if (this.fastLayer[y][x] === 1) {
                                // Fast layer can activate slow layer neighbors
                                for (let dy = -1; dy <= 1; dy++) {
                                    for (let dx = -1; dx <= 1; dx++) {
                                        if (dx === 0 && dy === 0) continue;

                                        const nx = (x + dx + this.gridSize) % this.gridSize;
                                        const ny = (y + dy + this.gridSize) % this.gridSize;

                                        if (Math.random() < 0.1) {
                                            this.slowLayer[ny][nx] = 1;
                                        }
                                    }
                                }
                            }

                            if (this.slowLayer[y][x] === 1) {
                                // Slow layer can activate fast layer neighbors
                                for (let dy = -1; dy <= 1; dy++) {
                                    for (let dx = -1; dx <= 1; dx++) {
                                        if (dx === 0 && dy === 0) continue;

                                        const nx = (x + dx + this.gridSize) % this.gridSize;
                                        const ny = (y + dy + this.gridSize) % this.gridSize;

                                        if (Math.random() < 0.05) {
                                            this.fastLayer[ny][nx] = 1;
                                        }
                                    }
                                }
                            }
                        }
                    }
                    break;

                case 'competition':
                    for (let y = 0; y < this.gridSize; y++) {
                        for (let x = 0; x < this.gridSize; x++) {
                            if (this.fastLayer[y][x] === 1 && this.slowLayer[y][x] === 1) {
                                // Competition - random winner
                                if (Math.random() < 0.7) { // Fast layer advantage
                                    this.slowLayer[y][x] = 0;
                                } else {
                                    this.fastLayer[y][x] = 0;
                                }
                            }
                        }
                    }
                    break;
            }
        }

        updateStats() {
            document.getElementById('generation').textContent = this.generation;

            const totalSteps = this.ants.reduce((sum, ant) => sum + ant.steps, 0);
            document.getElementById('antSteps').textContent = totalSteps;

            // Count live cells in each layer
            let fastLiveCells = 0;
            let slowLiveCells = 0;

            for (let y = 0; y < this.gridSize; y++) {
                for (let x = 0; x < this.gridSize; x++) {
                    if (this.fastLayer[y][x] === 1) fastLiveCells++;
                    if (this.slowLayer[y][x] === 1) slowLiveCells++;
                }
            }

            document.getElementById('fastLiveCells').textContent = fastLiveCells;
            document.getElementById('slowLiveCells').textContent = slowLiveCells;
            document.getElementById('fastSteps').textContent = this.fastSteps;
            document.getElementById('slowSteps').textContent = this.slowSteps;
        }

        draw() {
            // Clear pixel data
            this.pixelData.fill(0);

            // Draw substrate
            for (let y = 0; y < this.gridSize; y++) {
                for (let x = 0; x < this.gridSize; x++) {
                    const state = this.substrateGrid[y][x];
                    const color = state === 0 ? {r: 20, g: 20, b: 20} : {r: 60, g: 60, b: 60};

                    for (let py = 0; py < this.cellSize; py++) {
                        for (let px = 0; px < this.cellSize; px++) {
                            const pixelX = x * this.cellSize + px;
                            const pixelY = y * this.cellSize + py;
                            const index = (pixelY * this.canvas.width + pixelX) * 4;

                            this.pixelData[index] = color.r;
                            this.pixelData[index + 1] = color.g;
                            this.pixelData[index + 2] = color.b;
                            this.pixelData[index + 3] = 255;
                        }
                    }
                }
            }

            // Draw fast layer (green)
            for (let y = 0; y < this.gridSize; y++) {
                for (let x = 0; x < this.gridSize; x++) {
                    if (this.fastLayer[y][x] === 1) {
                        for (let py = 0; py < this.cellSize; py++) {
                            for (let px = 0; px < this.cellSize; px++) {
                                const pixelX = x * this.cellSize + px;
                                const pixelY = y * this.cellSize + py;
                                const index = (pixelY * this.canvas.width + pixelX) * 4;

                                // Blend with existing color
                                this.pixelData[index] = Math.min(255, this.pixelData[index] + 50);
                                this.pixelData[index + 1] = Math.min(255, this.pixelData[index + 1] + 200);
                                this.pixelData[index + 2] = Math.min(255, this.pixelData[index + 2] + 50);
                            }
                        }
                    }
                }
            }

            // Draw slow layer (blue)
            for (let y = 0; y < this.gridSize; y++) {
                for (let x = 0; x < this.gridSize; x++) {
                    if (this.slowLayer[y][x] === 1) {
                        for (let py = 0; py < this.cellSize; py++) {
                            for (let px = 0; px < this.cellSize; px++) {
                                const pixelX = x * this.cellSize + px;
                                const pixelY = y * this.cellSize + py;
                                const index = (pixelY * this.canvas.width + pixelX) * 4;

                                // Blend with existing color
                                this.pixelData[index] = Math.min(255, this.pixelData[index] + 50);
                                this.pixelData[index + 1] = Math.min(255, this.pixelData[index + 1] + 50);
                                this.pixelData[index + 2] = Math.min(255, this.pixelData[index + 2] + 200);
                            }
                        }
                    }
                }
            }

            // Put the image data to canvas
            this.ctx.putImageData(this.imageData, 0, 0);

            // Draw ants
            for (let ant of this.ants) {
                this.ctx.fillStyle = ant.color;
                this.ctx.shadowColor = ant.color;
                this.ctx.shadowBlur = 3;
                this.ctx.fillRect(
                    ant.x * this.cellSize + this.cellSize * 0.2,
                    ant.y * this.cellSize + this.cellSize * 0.2,
                    this.cellSize * 0.6,
                    this.cellSize * 0.6
                );

                // Draw direction indicator
                this.ctx.fillStyle = '#ffff00';
                this.ctx.shadowColor = '#ffff00';
                const centerX = ant.x * this.cellSize + this.cellSize * 0.5;
                const centerY = ant.y * this.cellSize + this.cellSize * 0.5;
                const dx = [0, 1, 0, -1][ant.dir] * this.cellSize * 0.3;
                const dy = [-1, 0, 1, 0][ant.dir] * this.cellSize * 0.3;

                this.ctx.beginPath();
                this.ctx.arc(centerX + dx, centerY + dy, this.cellSize * 0.1, 0, 2 * Math.PI);
                this.ctx.fill();

                // Draw ant ID for multiple ants
                if (this.numAnts > 1) {
                    this.ctx.fillStyle = '#ffffff';
                    this.ctx.font = `${Math.max(8, this.cellSize * 0.4)}px monospace`;
                    this.ctx.textAlign = 'center';
                    this.ctx.fillText(
                        ant.id.toString(),
                        centerX,
                        centerY + this.cellSize * 0.15
                    );
                }
            }

            this.ctx.shadowBlur = 0;
        }
    }

    new DualLayerConway();
</script>
</body>
</html>