<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>MinkowskiRBFLayer Visualization</title>
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@4.15.0/dist/tf.min.js"></script>
    <style>
        :root {
            --bg-color: #0f172a;
            --card-bg: #1e293b;
            --text-primary: #f1f5f9;
            --text-secondary: #94a3b8;
            --accent-cyan: #06b6d4;
            --accent-magenta: #d946ef;
            --accent-green: #22c55e;
            --border-color: #334155;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
            background-color: var(--bg-color);
            color: var(--text-primary);
            margin: 0;
            padding: 20px;
            line-height: 1.5;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
        }

        header {
            margin-bottom: 30px;
            border-bottom: 1px solid var(--border-color);
            padding-bottom: 20px;
        }

        h1 {
            margin: 0;
            font-size: 2rem;
            background: linear-gradient(to right, var(--accent-cyan), var(--accent-magenta));
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
        }

        .subtitle {
            color: var(--text-secondary);
            margin-top: 5px;
        }

        .controls {
            background-color: var(--card-bg);
            padding: 20px;
            border-radius: 8px;
            margin-bottom: 20px;
            display: flex;
            gap: 20px;
            flex-wrap: wrap;
            align-items: center;
            border: 1px solid var(--border-color);
        }

        .control-group {
            display: flex;
            flex-direction: column;
            gap: 5px;
            min-width: 200px;
        }

        label {
            font-size: 0.875rem;
            color: var(--text-secondary);
            font-weight: 600;
        }

        input[type="range"] {
            width: 100%;
            accent-color: var(--accent-cyan);
        }

        .value-display {
            font-family: monospace;
            color: var(--accent-cyan);
            font-size: 0.9rem;
        }

        button {
            background-color: var(--accent-cyan);
            color: var(--bg-color);
            border: none;
            padding: 8px 16px;
            border-radius: 4px;
            cursor: pointer;
            font-weight: 600;
            transition: opacity 0.2s;
        }

        button:hover {
            opacity: 0.9;
        }

        .grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(400px, 1fr));
            gap: 20px;
            margin-bottom: 30px;
        }

        .card {
            background-color: var(--card-bg);
            border-radius: 8px;
            padding: 15px;
            border: 1px solid var(--border-color);
            display: flex;
            flex-direction: column;
        }

        .card-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px;
        }

        .card-title {
            font-weight: 600;
            color: var(--text-primary);
        }

        canvas {
            background-color: #000;
            border-radius: 4px;
            width: 100%;
            height: 400px;
            cursor: crosshair;
        }

        .legend {
            display: flex;
            gap: 15px;
            font-size: 0.8rem;
            margin-top: 10px;
        }

        .legend-item {
            display: flex;
            align-items: center;
            gap: 5px;
        }

        .dot {
            width: 10px;
            height: 10px;
            border-radius: 50%;
        }

        .info-panel {
            background-color: var(--card-bg);
            padding: 20px;
            border-radius: 8px;
            border: 1px solid var(--border-color);
            font-size: 0.95rem;
        }

        code {
            background-color: rgba(0,0,0,0.3);
            padding: 2px 4px;
            border-radius: 3px;
            font-family: monospace;
            color: var(--accent-magenta);
        }

        .math-block {
            background-color: rgba(0,0,0,0.3);
            padding: 15px;
            border-radius: 4px;
            font-family: monospace;
            margin: 10px 0;
            overflow-x: auto;
        }

        /* Tooltip */
        #tooltip {
            position: absolute;
            background: rgba(0, 0, 0, 0.9);
            color: white;
            padding: 5px 10px;
            border-radius: 4px;
            font-size: 12px;
            pointer-events: none;
            display: none;
            z-index: 100;
            border: 1px solid var(--border-color);
        }
    </style>

    <style>
        /* =========================================
           1. Variables & Reset
           ========================================= */
        :root {
            /* Color Palette - Dark Sci-Fi Theme */
            --bg-color: #0f172a;        /* Deep Slate */
            --card-bg: #1e293b;         /* Lighter Slate */
            --card-border: #334155;     /* Border Slate */

            --text-primary: #f8fafc;    /* White-ish */
            --text-secondary: #94a3b8;  /* Muted Blue-Grey */

            /* Accents matching the Physics Visualization */
            --accent-cyan: #06b6d4;     /* Timelike */
            --accent-magenta: #d946ef;  /* Spacelike */
            --accent-yellow: #facc15;   /* Reference Points */
            --accent-green: #22c55e;    /* Success/Action */

            /* Spacing & Layout */
            --radius-sm: 6px;
            --radius-md: 12px;
            --spacing-unit: 1rem;
            --transition-speed: 0.2s;
        }

        *, *::before, *::after {
            box-sizing: border-box;
        }

        body {
            font-family: 'Inter', -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
            background-color: var(--bg-color);
            color: var(--text-primary);
            margin: 0;
            padding: 20px;
            line-height: 1.6;
            -webkit-font-smoothing: antialiased;
        }

        /* =========================================
           2. Layout & Container
           ========================================= */
        .container {
            max-width: 1400px;
            margin: 0 auto;
            padding: 0 var(--spacing-unit);
        }

        /* =========================================
           3. Header Typography
           ========================================= */
        header {
            margin-bottom: 2.5rem;
            border-bottom: 1px solid var(--card-border);
            padding-bottom: 1.5rem;
            text-align: center;
        }

        h1 {
            margin: 0;
            font-size: clamp(1.8rem, 4vw, 2.5rem);
            font-weight: 800;
            letter-spacing: -0.02em;
            background: linear-gradient(135deg, var(--accent-cyan), var(--accent-magenta));
            -webkit-background-clip: text;
            background-clip: text;
            -webkit-text-fill-color: transparent;
            text-shadow: 0 2px 10px rgba(6, 182, 212, 0.2);
        }

        .subtitle {
            color: var(--text-secondary);
            margin-top: 0.5rem;
            font-size: 1.1rem;
            font-weight: 400;
        }

        /* =========================================
           4. Controls Section
           ========================================= */
        .controls {
            background-color: var(--card-bg);
            padding: 1.5rem;
            border-radius: var(--radius-md);
            margin-bottom: 2rem;
            display: flex;
            gap: 2rem;
            flex-wrap: wrap;
            align-items: center;
            border: 1px solid var(--card-border);
            box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -1px rgba(0, 0, 0, 0.06);
        }

        .control-group {
            display: flex;
            flex-direction: column;
            gap: 0.5rem;
            min-width: 200px;
            flex: 1;
        }

        label {
            font-size: 0.85rem;
            color: var(--text-secondary);
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.05em;
            display: flex;
            justify-content: space-between;
        }

        .value-display {
            font-family: 'JetBrains Mono', 'Fira Code', monospace;
            color: var(--accent-cyan);
            font-weight: 700;
        }

        /* Custom Range Slider Styling */
        input[type="range"] {
            -webkit-appearance: none;
            width: 100%;
            background: transparent;
            cursor: pointer;
        }

        input[type="range"]:focus {
            outline: none;
        }

        /* Slider Track */
        input[type="range"]::-webkit-slider-runnable-track {
            width: 100%;
            height: 6px;
            background: var(--bg-color);
            border-radius: 3px;
            border: 1px solid var(--card-border);
        }

        input[type="range"]::-moz-range-track {
            width: 100%;
            height: 6px;
            background: var(--bg-color);
            border-radius: 3px;
            border: 1px solid var(--card-border);
        }

        /* Slider Thumb */
        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            height: 18px;
            width: 18px;
            border-radius: 50%;
            background: var(--accent-cyan);
            margin-top: -7px; /* Centers thumb on track */
            box-shadow: 0 0 10px rgba(6, 182, 212, 0.5);
            transition: transform 0.1s;
        }

        input[type="range"]::-moz-range-thumb {
            height: 18px;
            width: 18px;
            border: none;
            border-radius: 50%;
            background: var(--accent-cyan);
            box-shadow: 0 0 10px rgba(6, 182, 212, 0.5);
            transition: transform 0.1s;
        }

        input[type="range"]:active::-webkit-slider-thumb {
            transform: scale(1.2);
        }

        /* Buttons */
        button {
            background: linear-gradient(to bottom right, var(--accent-cyan), #0891b2);
            color: white;
            border: none;
            padding: 0.75rem 1.5rem;
            border-radius: var(--radius-sm);
            cursor: pointer;
            font-weight: 600;
            font-size: 0.9rem;
            transition: all var(--transition-speed);
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.2);
            text-shadow: 0 1px 2px rgba(0,0,0,0.2);
        }

        button:hover {
            filter: brightness(1.1);
            transform: translateY(-1px);
            box-shadow: 0 6px 8px rgba(0, 0, 0, 0.3);
        }

        button:active {
            transform: translateY(0);
        }

        /* Status Text */
        #status {
            font-family: 'JetBrains Mono', monospace;
            padding: 0.5rem;
            background: rgba(0,0,0,0.2);
            border-radius: 4px;
            border-left: 3px solid var(--accent-green);
        }

        /* =========================================
           5. Grid & Cards
           ========================================= */
        .grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(380px, 1fr));
            gap: 1.5rem;
            margin-bottom: 2rem;
        }

        .card {
            background-color: var(--card-bg);
            border-radius: var(--radius-md);
            padding: 1.25rem;
            border: 1px solid var(--card-border);
            display: flex;
            flex-direction: column;
            transition: transform 0.2s, box-shadow 0.2s;
        }

        .card:hover {
            border-color: #475569;
            box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.2);
        }

        .card-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 1rem;
            padding-bottom: 0.75rem;
            border-bottom: 1px solid rgba(255,255,255,0.05);
        }

        .card-title {
            font-weight: 700;
            color: var(--text-primary);
            font-size: 1.1rem;
        }

        /* =========================================
           6. Canvas & Visualization
           ========================================= */
        canvas {
            background-color: #020617; /* Very dark blue/black */
            border-radius: var(--radius-sm);
            width: 100%;
            height: 350px; /* Fixed height for consistency */
            cursor: crosshair;
            border: 1px solid #334155;
            box-shadow: inset 0 0 20px rgba(0,0,0,0.5);
        }

        /* =========================================
           7. Legend
           ========================================= */
        .legend {
            display: flex;
            flex-wrap: wrap;
            gap: 1rem;
            font-size: 0.85rem;
            margin-top: 1rem;
            padding-top: 0.5rem;
            color: var(--text-secondary);
        }

        .legend-item {
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .dot {
            width: 12px;
            height: 12px;
            border-radius: 50%;
            box-shadow: 0 0 5px rgba(0,0,0,0.5);
            border: 1px solid rgba(255,255,255,0.1);
        }

        /* =========================================
           8. Info Panel & Math
           ========================================= */
        .info-panel {
            background-color: var(--card-bg);
            padding: 2rem;
            border-radius: var(--radius-md);
            border: 1px solid var(--card-border);
            font-size: 1rem;
            line-height: 1.7;
            max-width: 900px;
            margin: 0 auto;
        }

        .info-panel h3 {
            margin-top: 0;
            color: var(--accent-cyan);
            border-bottom: 1px solid var(--card-border);
            padding-bottom: 0.5rem;
            display: inline-block;
        }

        code {
            background-color: rgba(0, 0, 0, 0.3);
            padding: 0.2em 0.4em;
            border-radius: 4px;
            font-family: 'JetBrains Mono', monospace;
            font-size: 0.9em;
            color: var(--accent-magenta);
            border: 1px solid rgba(217, 70, 239, 0.2);
        }

        .math-block {
            background-color: #020617;
            padding: 1.5rem;
            border-radius: var(--radius-sm);
            font-family: 'JetBrains Mono', monospace;
            margin: 1.5rem 0;
            overflow-x: auto;
            border-left: 4px solid var(--accent-cyan);
            color: var(--text-primary);
            box-shadow: inset 0 2px 4px rgba(0,0,0,0.3);
            text-align: center;
            font-size: 1.1rem;
        }

        .info-panel ul {
            padding-left: 1.5rem;
        }

        .info-panel li {
            margin-bottom: 0.5rem;
        }

        /* =========================================
           9. Tooltip
           ========================================= */
        #tooltip {
            position: absolute;
            background: rgba(15, 23, 42, 0.95);
            color: var(--text-primary);
            padding: 8px 12px;
            border-radius: 4px;
            font-size: 0.8rem;
            pointer-events: none;
            display: none;
            z-index: 100;
            border: 1px solid var(--accent-cyan);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.5);
            backdrop-filter: blur(4px);
            white-space: nowrap;
        }

        /* =========================================
           10. Responsive Adjustments
           ========================================= */
        @media (max-width: 768px) {
            .controls {
                flex-direction: column;
                align-items: stretch;
                gap: 1.5rem;
            }

            .control-group {
                min-width: 100%;
            }

            .grid {
                grid-template-columns: 1fr;
            }

            h1 {
                font-size: 1.8rem;
            }

            canvas {
                height: 300px;
            }
        }
    </style>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>MinkowskiRBFLayer Visualization</title>
    <meta name="description"
          content="Interactive visualization of a Neural Network layer operating in pseudo-Riemannian spacetime using TensorFlow.js.">
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@4.15.0/dist/tf.min.js"></script>
    <style>
        :root {
            --bg-color: #0f172a;
            --card-bg: #1e293b;
            --text-primary: #f1f5f9;
            --text-secondary: #94a3b8;
            --accent-cyan: #06b6d4;
            --accent-magenta: #d946ef;
            --accent-green: #22c55e;
            --border-color: #334155;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
            background-color: var(--bg-color);
            color: var(--text-primary);
            margin: 0;
            padding: 20px;
            line-height: 1.5;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
        }

        header {
            margin-bottom: 30px;
            border-bottom: 1px solid var(--border-color);
            padding-bottom: 20px;
        }

        h1 {
            margin: 0;
            font-size: 2rem;
            background: linear-gradient(to right, var(--accent-cyan), var(--accent-magenta));
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
        }

        .subtitle {
            color: var(--text-secondary);
            margin-top: 5px;
        }

        .controls {
            background-color: var(--card-bg);
            padding: 20px;
            border-radius: 8px;
            margin-bottom: 20px;
            display: flex;
            gap: 20px;
            flex-wrap: wrap;
            align-items: center;
            border: 1px solid var(--border-color);
        }

        .control-group {
            display: flex;
            flex-direction: column;
            gap: 5px;
            min-width: 200px;
        }

        label {
            font-size: 0.875rem;
            color: var(--text-secondary);
            font-weight: 600;
        }

        input[type="range"] {
            width: 100%;
            accent-color: var(--accent-cyan);
            cursor: pointer;
        }

        .value-display {
            font-family: monospace;
            color: var(--accent-cyan);
            font-size: 0.9rem;
        }

        button {
            background-color: var(--accent-cyan);
            color: var(--bg-color);
            border: none;
            padding: 8px 16px;
            border-radius: 4px;
            cursor: pointer;
            font-weight: 600;
            transition: opacity 0.2s;
        }

        button:hover {
            opacity: 0.9;
        }

        .grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(400px, 1fr));
            gap: 20px;
            margin-bottom: 30px;
        }

        .card {
            background-color: var(--card-bg);
            border-radius: 8px;
            padding: 15px;
            border: 1px solid var(--border-color);
            display: flex;
            flex-direction: column;
        }

        .card-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px;
        }

        .card-title {
            font-weight: 600;
            color: var(--text-primary);
        }

        canvas {
            background-color: #000;
            border-radius: 4px;
            width: 100%;
            height: 400px;
            cursor: crosshair;
        }

        .legend {
            display: flex;
            gap: 15px;
            font-size: 0.8rem;
            margin-top: 10px;
            flex-wrap: wrap;
        }

        .legend-item {
            display: flex;
            align-items: center;
            gap: 5px;
        }

        .dot {
            width: 10px;
            height: 10px;
            border-radius: 50%;
        }

        .info-panel {
            background-color: var(--card-bg);
            padding: 20px;
            border-radius: 8px;
            border: 1px solid var(--border-color);
            font-size: 0.95rem;
        }

        code {
            background-color: rgba(0,0,0,0.3);
            padding: 2px 4px;
            border-radius: 3px;
            font-family: monospace;
            color: var(--accent-magenta);
        }

        .math-block {
            background-color: rgba(0,0,0,0.3);
            padding: 15px;
            border-radius: 4px;
            font-family: monospace;
            margin: 10px 0;
            overflow-x: auto;
            color: #e2e8f0;
        }

        /* Tooltip */
        #tooltip {
            position: absolute;
            background: rgba(0, 0, 0, 0.9);
            color: white;
            padding: 5px 10px;
            border-radius: 4px;
            font-size: 12px;
            pointer-events: none;
            display: none;
            z-index: 100;
            border: 1px solid var(--border-color);
        }

        @media (max-width: 600px) {
            .grid {
                grid-template-columns: 1fr;
            }
            canvas {
                height: 300px;
            }
        }
    </style>
</head>
<body>


<div class="container">
    <header>
        <h1>MinkowskiRBFLayer Analysis</h1>
        <div class="subtitle">TensorFlow.js Implementation & Spacetime Visualization</div>
    </header>

    <div class="controls">
        <div class="control-group">
            <label>Speed of Light (c): <span id="c-val" class="value-display">1.0</span></label>
            <input type="range" id="c-slider" min="0.1" max="5.0" step="0.1" value="1.0">
        </div>
        <div class="control-group">
            <label>Projection Scale: <span id="scale-val" class="value-display">1.0</span></label>
            <input type="range" id="scale-slider" min="0.1" max="3.0" step="0.1" value="1.0">
        </div>
        <div class="control-group">
            <label>Actions</label>
            <button id="reset-btn">Randomize Weights & Data</button>
        </div>
        <div class="control-group">
            <label>Training</label>
            <button id="train-btn">Train (SGD)</button>
        </div>
        <div class="control-group" style="flex: 1; min-width: 200px;">
            <label>Status / Loss: <span id="loss-val" class="value-display">--</span></label>
            <div id="status" style="font-size: 0.85rem; color: var(--text-secondary);">Initializing TensorFlow.js...
            </div>
        </div>
    </div>

    <div class="grid">
        <!-- Input Space -->
        <div class="card">
            <div class="card-header">
                <span class="card-title">1. Input Space (2D Euclidean)</span>
            </div>
            <canvas id="canvas-input"></canvas>
            <div class="legend">
                <div class="legend-item">
                    <div class="dot" style="background: #fff;"></div>
                    Data Points
                </div>
            </div>
        </div>

        <!-- Spacetime Projection -->
        <div class="card">
            <div class="card-header">
                <span class="card-title">2. Minkowski Spacetime Projection (1+1D)</span>
                <span style="font-size: 0.8rem; color: var(--accent-magenta);">Y: Time, X: Space</span>
            </div>
            <canvas id="canvas-proj"></canvas>
            <div class="legend">
                <div class="legend-item">
                    <div class="dot" style="background: #ffff00;"></div>
                    Reference Points
                </div>
                <div class="legend-item">
                    <div class="dot" style="background: var(--accent-cyan);"></div>
                    Timelike (Real)
                </div>
                <div class="legend-item">
                    <div class="dot" style="background: var(--accent-magenta);"></div>
                    Spacelike (Imag)
                </div>
            </div>
        </div>

        <!-- Output Activation -->
        <div class="card">
            <div class="card-header">
                <span class="card-title">3. Layer Output (Complex Magnitude)</span>
                <span id="output-label" style="font-size: 0.8rem; color: var(--text-secondary);">Select a reference point</span>
            </div>
            <canvas id="canvas-output"></canvas>
            <div class="legend">
                <div class="legend-item">
                    <div class="dot"
                         style="background: linear-gradient(to right, black, var(--accent-cyan)); width: 30px; border-radius: 2px;"></div>
                    Timelike Strength
                </div>
                <div class="legend-item">
                    <div class="dot"
                         style="background: linear-gradient(to right, black, var(--accent-magenta)); width: 30px; border-radius: 2px;"></div>
                    Spacelike Strength
                </div>
            </div>
        </div>
    </div>

    <div class="info-panel">
        <h3>How it Works</h3>
        <p>
            The <strong>MinkowskiRBFLayer</strong> projects input data into a pseudo-Riemannian manifold (Minkowski
            spacetime) and computes distances to learned reference points using the Minkowski metric.
        </p>
        <div class="math-block">
            ds² = -c²(Δt)² + (Δx)²
        </div>
        <p>
            Unlike standard Euclidean distance, this metric distinguishes between two fundamental types of
            relationships:
        </p>
        <ul>
            <li><strong style="color: var(--accent-cyan)">Timelike (ds² < 0):</strong> Events are causally connected.
                The output is a <strong>Real</strong> number representing the proper time.
            </li>
            <li><strong style="color: var(--accent-magenta)">Spacelike (ds² > 0):</strong> Events are causally
                disconnected. The output is an <strong>Imaginary</strong> number representing the proper distance.
            </li>
        </ul>
        <p>
            <strong>Interaction:</strong> Hover over the "Spacetime Projection" canvas. The yellow stars are reference
            points. The cursor acts as a probe, showing the light cone (white X). Points inside the top/bottom cones are
            Timelike (Cyan), points outside are Spacelike (Magenta).
        </p>
    </div>
</div>

<div id="tooltip"></div>

<script>
    /**
     * MinkowskiRBFLayer Implementation in TensorFlow.js
     *
     * This class implements a neural network layer that projects data into Minkowski spacetime
     * and calculates activations based on the spacetime interval (ds^2).
     */
    class MinkowskiRBFLayer {
        constructor(inputDim, spacetimeDim, numRefs, c = 1.0) {
            this.inputDim = inputDim;
            this.spacetimeDim = spacetimeDim; // 1 time + S space
            this.numRefs = numRefs;

            // Initialize parameters
            // W_proj: Projection matrix [D, 1+S]
            this.W = tf.variable(tf.randomNormal([inputDim, spacetimeDim], 0, 0.5));

            // b_proj: Bias [1+S]
            this.b = tf.variable(tf.zeros([spacetimeDim]));

            // Reference points in spacetime [M, 1+S]
            // Initialized uniformly in [-1, 1]
            this.refs = tf.variable(tf.randomUniform([numRefs, spacetimeDim], -0.8, 0.8));

            // Speed of light parameter
            this.c = tf.scalar(c);
        }

        updateC(newC) {
            this.c.dispose();
            this.c = tf.scalar(newC);
        }

        updateWeights(scale) {
            this.W.dispose();
            this.W = tf.variable(tf.randomNormal([this.inputDim, this.spacetimeDim], 0, scale));
            this.refs.dispose();
            this.refs = tf.variable(tf.randomUniform([this.numRefs, this.spacetimeDim], -0.8, 0.8));
        }

        /**
         * Forward pass
         * @param {tf.Tensor} x Input tensor [N, D]
         * @returns {Object} Result containing projections, intervals, and complex outputs
         */
        forward(x) {
            return tf.tidy(() => {
                // 1. Project to Spacetime: P = X @ W + b
                const P = x.matMul(this.W).add(this.b); // [N, 1+S]

                // 2. Compute Differences
                // Expand P to [N, 1, 1+S] and Refs to [1, M, 1+S] for broadcasting
                const P_exp = P.expandDims(1);
                const R_exp = this.refs.expandDims(0);
                const diff = P_exp.sub(R_exp); // [N, M, 1+S]

                // 3. Split into Temporal and Spatial components
                // Assuming index 0 is time (t), 1..S are space (x)
                const dt = diff.slice([0, 0, 0], [-1, -1, 1]).squeeze(-1); // [N, M]
                const dx = diff.slice([0, 0, 1], [-1, -1, -1]); // [N, M, S]

                // 4. Minkowski Metric: ds² = -c²Δt² + ||Δx||²
                const c2 = this.c.square();
                const term_t = dt.square().mul(c2).neg(); // -c²Δt²
                const term_x = dx.square().sum(-1); // ||Δx||²

const ds2 = term_t.add(term_x); // [N, M]

                // 5. Complex Encoding




                // Timelike (ds² < 0): z = -sqrt(-ds²) (Real)
                // Spacelike (ds² > 0): z = i*sqrt(ds²) (Imaginary)
                // We use ReLU and safe sqrt to ensure differentiability.

                const eps = 1e-7;
                const sqrtEps = Math.sqrt(eps);

                // Real part: derived from ds2 < 0
                // sqrt(ReLU(-ds2))
                const relu_neg = tf.relu(ds2.neg());
                const real_mag = relu_neg.add(eps).sqrt().sub(sqrtEps);
                const real = real_mag.neg();

                // Imag part: derived from ds2 > 0
                // sqrt(ReLU(ds2))
                const relu_pos = tf.relu(ds2);
                const imag = relu_pos.add(eps).sqrt().sub(sqrtEps);

                return {
                    P: P,       // Projected points [N, 1+S]
                    ds2: ds2,   // Spacetime intervals [N, M]
                    real: real, // Real output component [N, M]
                    imag: imag, // Imag output component [N, M]
                    refs: this.refs.clone() // Reference points
                };
            });
        }
    }

    // --- Application Logic ---

    // Configuration
    const CONFIG = {
        numPoints: 300,
        numClasses: 3,
        inputDim: 2,
        spacetimeDim: 2, // 1 Time + 1 Space for easy visualization
        numRefs: 5,
        c: 1.0,
        learningRate: 0.05
    };

    // State
    let layer;
    let inputData;
    let inputLabels; // One-hot encoded
    let W_head, b_head; // Classifier head weights
    let isTraining = false;
    let activeRefIndex = 0; // Which reference point to visualize details for
    let mousePos = { x: 0, y: 0, active: false };
    let optimizer;

    // DOM Elements
    const canvasInput = document.getElementById('canvas-input');
    const canvasProj = document.getElementById('canvas-proj');
    const canvasOutput = document.getElementById('canvas-output');
    const cSlider = document.getElementById('c-slider');
    const cVal = document.getElementById('c-val');
    const scaleSlider = document.getElementById('scale-slider');
    const scaleVal = document.getElementById('scale-val');
    const resetBtn = document.getElementById('reset-btn');
    const trainBtn = document.getElementById('train-btn');
    const lossVal = document.getElementById('loss-val');
    const statusDiv = document.getElementById('status');
    const tooltip = document.getElementById('tooltip');
    const outputLabel = document.getElementById('output-label');

    // Initialization
    async function init() {
        statusDiv.textContent = "Generating tensors...";

        generateData();

        // Create Layer
        layer = new MinkowskiRBFLayer(CONFIG.inputDim, CONFIG.spacetimeDim, CONFIG.numRefs, CONFIG.c);

        // Initialize Classifier Head
        initClassifier();

        // Optimizer
        optimizer = tf.train.adam(CONFIG.learningRate);

        // Event Listeners
        setupEventListeners();

        statusDiv.textContent = "Ready. Hover over Projection canvas to inspect light cones.";

        // Initial Render
        requestAnimationFrame(render);
    }

    function generateData() {
        if(inputData) inputData.dispose();
        if(inputLabels) inputLabels.dispose();

        tf.tidy(() => {
            const c1 = tf.randomNormal([CONFIG.numPoints/3, 2], 0, 0.3).add(tf.tensor1d([-0.5, -0.5]));
            const c2 = tf.randomNormal([CONFIG.numPoints/3, 2], 0, 0.3).add(tf.tensor1d([0.5, 0.5]));
            const c3 = tf.randomNormal([CONFIG.numPoints/3, 2], 0, 0.3).add(tf.tensor1d([0.5, -0.5]));

            const x = tf.concat([c1, c2, c3]);

            // Labels: 0, 1, 2
            const l1 = tf.zeros([CONFIG.numPoints/3], 'int32');
            const l2 = tf.ones([CONFIG.numPoints/3], 'int32');
const l3 = tf.fill([CONFIG.numPoints/3], 2, 'int32');
            const y = tf.concat([l1, l2, l3]);

            inputData = tf.keep(x);
            inputLabels = tf.keep(tf.oneHot(y, CONFIG.numClasses));
        });
    }

    function initClassifier() {
        if(W_head) W_head.dispose();
        if(b_head) b_head.dispose();

        // Input to head is [Real, Imag] concatenated -> 2 * numRefs
        W_head = tf.variable(tf.randomNormal([CONFIG.numRefs * 2, CONFIG.numClasses], 0, 0.5));
        b_head = tf.variable(tf.zeros([CONFIG.numClasses]));
    }

    function setupEventListeners() {
        cSlider.addEventListener('input', (e) => {
            const val = parseFloat(e.target.value);
            CONFIG.c = val;
            cVal.textContent = val.toFixed(1);
            layer.updateC(val);
            requestAnimationFrame(render);
        });

        scaleSlider.addEventListener('input', (e) => {
            const val = parseFloat(e.target.value);
            scaleVal.textContent = val.toFixed(1);
            layer.updateWeights(val);
            requestAnimationFrame(render);
        });

        resetBtn.addEventListener('click', () => {
            isTraining = false;
            trainBtn.textContent = "Train (SGD)";
            layer.updateWeights(parseFloat(scaleSlider.value));
            generateData();
            initClassifier();
            requestAnimationFrame(render);
        });
        trainBtn.addEventListener('click', () => {
            isTraining = !isTraining;
            trainBtn.textContent = isTraining ? "Stop Training" : "Train (SGD)";
            if(isTraining) trainLoop();
        });


        // Canvas Interaction for Projection View
        canvasProj.addEventListener('mousemove', (e) => {
            const rect = canvasProj.getBoundingClientRect();
            const x = (e.clientX - rect.left) / rect.width; // 0 to 1
            const y = (e.clientY - rect.top) / rect.height; // 0 to 1

            // Map to coordinate space [-2, 2]
            mousePos.x = x * 4 - 2;
            mousePos.y = -(y * 4 - 2); // Flip Y
            mousePos.active = true;

            // Find closest reference point
            findClosestRef(mousePos.x, mousePos.y);

            requestAnimationFrame(render);
        });

        canvasProj.addEventListener('mouseleave', () => {
            mousePos.active = false;
            requestAnimationFrame(render);
        });


    }

    async function trainLoop() {
        if(!isTraining) return;

        const lossValue = optimizer.minimize(() => {
            const { real, imag } = layer.forward(inputData);
            // Concatenate real and imaginary parts as features
            const features = tf.concat([real, imag], 1);
            // Linear classifier
            const logits = features.matMul(W_head).add(b_head);
            return tf.losses.softmaxCrossEntropy(inputLabels, logits);
        }, true);

        const l = await lossValue.data();
        lossVal.textContent = l[0].toFixed(4);
        lossValue.dispose();

        await render();

        if(isTraining) {
            requestAnimationFrame(trainLoop);
        }
    }

    async function findClosestRef(mx, my) {
        const refs = await layer.refs.array();
        let minDist = Infinity;
        let idx = 0;

        // Simple Euclidean distance for UI selection
        for(let i=0; i<refs.length; i++) {
            // refs[i] is [t, x]
            // In our visualization Y is Time (0), X is Space (1)
            const t = refs[i][0];
            const x = refs[i][1];
            const dist = Math.sqrt((t - my)**2 + (x - mx)**2);
            if(dist < minDist) {
                minDist = dist;
                idx = i;
            }
        }

        if (minDist < 0.5) { // Only switch if reasonably close
            if (activeRefIndex !== idx) {
                activeRefIndex = idx;
                outputLabel.textContent = `Reference Point #${idx+1} Selected`;
                outputLabel.style.color = 'var(--accent-cyan)';
            }
        } else {
            outputLabel.style.color = 'var(--text-secondary)';
        }
    }

    // Rendering Logic
    async function render() {
        const result = layer.forward(inputData);

        const inputs = await inputData.array();
        const labels = await inputLabels.argMax(1).array(); // Get class indices
        const projected = await result.P.array();
        const refs = await result.refs.array();
        const ds2 = await result.ds2.array();
        const real = await result.real.array();
        const imag = await result.imag.array();

        // Clean up tensors
        tf.dispose([result.P, result.ds2, result.real, result.imag, result.refs]);

        drawInputSpace(inputs, labels);
        drawProjectionSpace(projected, refs, ds2, labels);
        drawOutputSpace(inputs, real, imag, labels);
    }

    function drawInputSpace(points, labels) {
        const ctx = canvasInput.getContext('2d');
        const w = canvasInput.width = canvasInput.clientWidth;
        const h = canvasInput.height = canvasInput.clientHeight;

        ctx.fillStyle = '#000';
        ctx.fillRect(0, 0, w, h);

        // Grid
        drawGrid(ctx, w, h);
        const colors = ['#ef4444', '#22c55e', '#3b82f6']; // Red, Green, Blue


        // Points
        points.forEach((p, i) => {
            const px = map(p[0], -2, 2, 0, w);
            const py = map(p[1], -2, 2, h, 0);
            ctx.fillStyle = colors[labels[i]] || '#fff';
            ctx.beginPath();
            ctx.arc(px, py, 2, 0, Math.PI*2);
            ctx.fill();
        });
    }

    function drawProjectionSpace(points, refs, ds2, labels) {
        const ctx = canvasProj.getContext('2d');
        const w = canvasProj.width = canvasProj.clientWidth;
        const h = canvasProj.height = canvasProj.clientHeight;

        ctx.fillStyle = '#000';
        ctx.fillRect(0, 0, w, h);

        drawGrid(ctx, w, h);

        // Draw Light Cone for Active Reference
        const activeRef = refs[activeRefIndex];
        if (activeRef) {
            const rt = activeRef[0]; // Time (Y)
            const rx = activeRef[1]; // Space (X)
            const c = CONFIG.c;

            ctx.strokeStyle = 'rgba(255, 255, 255, 0.2)';
            ctx.lineWidth = 2;

            // Light cone lines: t = rt ± (x - rx)/c
            // x = rx ± c(t - rt)

            ctx.beginPath();
            // Top cone
            ctx.moveTo(map(rx, -2, 2, 0, w), map(rt, -2, 2, h, 0));
            ctx.lineTo(map(rx + c*4, -2, 2, 0, w), map(rt + 4, -2, 2, h, 0));
            ctx.moveTo(map(rx, -2, 2, 0, w), map(rt, -2, 2, h, 0));
            ctx.lineTo(map(rx - c*4, -2, 2, 0, w), map(rt + 4, -2, 2, h, 0));

            // Bottom cone
            ctx.moveTo(map(rx, -2, 2, 0, w), map(rt, -2, 2, h, 0));
            ctx.lineTo(map(rx + c*4, -2, 2, 0, w), map(rt - 4, -2, 2, h, 0));
            ctx.moveTo(map(rx, -2, 2, 0, w), map(rt, -2, 2, h, 0));
            ctx.lineTo(map(rx - c*4, -2, 2, 0, w), map(rt - 4, -2, 2, h, 0));
            ctx.stroke();

            // Fill Timelike region slightly
            ctx.fillStyle = 'rgba(6, 182, 212, 0.1)'; // Cyan tint
            ctx.beginPath();
            ctx.moveTo(map(rx, -2, 2, 0, w), map(rt, -2, 2, h, 0));
            ctx.lineTo(map(rx + c*4, -2, 2, 0, w), map(rt + 4, -2, 2, h, 0));
            ctx.lineTo(map(rx - c*4, -2, 2, 0, w), map(rt + 4, -2, 2, h, 0));
            ctx.fill();

            ctx.beginPath();
            ctx.moveTo(map(rx, -2, 2, 0, w), map(rt, -2, 2, h, 0));
            ctx.lineTo(map(rx + c*4, -2, 2, 0, w), map(rt - 4, -2, 2, h, 0));
            ctx.lineTo(map(rx - c*4, -2, 2, 0, w), map(rt - 4, -2, 2, h, 0));
            ctx.fill();
        }
        const colors = ['#ef4444', '#22c55e', '#3b82f6'];


        // Draw Projected Points
        points.forEach((p, i) => {
            // p[0] is Time (Y), p[1] is Space (X)
            const px = map(p[1], -2, 2, 0, w);
            const py = map(p[0], -2, 2, h, 0);

            // We can color by class to see separation
            // Or by timelike/spacelike. Let's do class color with shape/stroke for interval type?
            // Let's stick to class color for the fill, and maybe stroke for timelike/spacelike
            const interval = ds2[i][activeRefIndex];
            const isTimelike = interval < 0;

            ctx.fillStyle = colors[labels[i]];
            ctx.strokeStyle = isTimelike ? '#06b6d4' : '#d946ef'; // Cyan vs Magenta border
            ctx.globalAlpha = 0.7;

            ctx.beginPath();
            ctx.arc(px, py, 3, 0, Math.PI*2);
            ctx.fill();
            ctx.stroke();
        });
        ctx.globalAlpha = 1.0;

        // Draw Reference Points
        refs.forEach((r, i) => {
            const rx = map(r[1], -2, 2, 0, w);
            const ry = map(r[0], -2, 2, h, 0);

            ctx.fillStyle = '#ffff00';
            ctx.beginPath();
            // Star shape or just big circle
            ctx.arc(rx, ry, i === activeRefIndex ? 8 : 5, 0, Math.PI*2);
            ctx.fill();

            if (i === activeRefIndex) {
                ctx.strokeStyle = '#fff';
                ctx.lineWidth = 2;
                ctx.stroke();
            }
        });

        // Draw Mouse Cursor Light Cone if active
        if (mousePos.active) {
            const mx = map(mousePos.x, -2, 2, 0, w);
            const my = map(mousePos.y, -2, 2, h, 0); // mousePos.y is already flipped in logic, but map expects cartesian
            // Wait, map expects value. mousePos.y is in [-2, 2].
            // map(val, -2, 2, h, 0) handles the flip.

            ctx.strokeStyle = 'rgba(255, 255, 255, 0.5)';
            ctx.setLineDash([5, 5]);
            ctx.lineWidth = 1;

            const c = CONFIG.c;
            const rt = mousePos.y;
            const rx = mousePos.x;

            ctx.beginPath();
            ctx.moveTo(map(rx - c*4, -2, 2, 0, w), map(rt + 4, -2, 2, h, 0));
            ctx.lineTo(map(rx + c*4, -2, 2, 0, w), map(rt - 4, -2, 2, h, 0));
            ctx.moveTo(map(rx + c*4, -2, 2, 0, w), map(rt + 4, -2, 2, h, 0));
            ctx.lineTo(map(rx - c*4, -2, 2, 0, w), map(rt - 4, -2, 2, h, 0));
            ctx.stroke();
            ctx.setLineDash([]);
        }
    }

    function drawOutputSpace(inputs, real, imag, labels) {
        const ctx = canvasOutput.getContext('2d');
        const w = canvasOutput.width = canvasOutput.clientWidth;
        const h = canvasOutput.height = canvasOutput.clientHeight;

        ctx.fillStyle = '#000';
        ctx.fillRect(0, 0, w, h);

        drawGrid(ctx, w, h);
        const colors = ['#ef4444', '#22c55e', '#3b82f6'];


        // Visualize the output for the ACTIVE reference point
        // We map the input points again, but color them by the output magnitude/phase

        inputs.forEach((p, i) => {
            const px = map(p[0], -2, 2, 0, w);
            const py = map(p[1], -2, 2, h, 0);

            const rVal = Math.abs(real[i][activeRefIndex]);
            const iVal = Math.abs(imag[i][activeRefIndex]);

// Normalize for visualization (clamp at 2.0)
 const rNorm = Math.min(rVal, 2.0) / 2.0;
            const iNorm = Math.min(iVal, 2.0) / 2.0;

            const size = 3 + (rNorm + iNorm) * 4;
            ctx.fillStyle = rVal > 0 ? `rgba(6, 182, 212, ${0.5 + rNorm/2})` : `rgba(217, 70, 239, ${0.5 + iNorm/2})`;
            ctx.beginPath();
            ctx.arc(px, py, size, 0, Math.PI*2);
            ctx.fill();
        });
    }

    // Utilities
    function map(val, inMin, inMax, outMin, outMax) {
        return (val - inMin) * (outMax - outMin) / (inMax - inMin) + outMin;
    }

    function drawGrid(ctx, w, h) {
        ctx.strokeStyle = '#334155';
        ctx.lineWidth = 1;

        // Center lines
        ctx.beginPath();
        ctx.moveTo(w/2, 0);
        ctx.lineTo(w/2, h);
        ctx.moveTo(0, h/2);
        ctx.lineTo(w, h/2);
        ctx.stroke();

        ctx.strokeStyle = '#1e293b';
        // Subgrid
        const step = w / 8;
        for(let i=0; i<w; i+=step) {
            ctx.beginPath();
            ctx.moveTo(i, 0);
            ctx.lineTo(i, h);
            ctx.stroke();
        }
        for(let i=0; i<h; i+=step) {
            ctx.beginPath();
            ctx.moveTo(0, i);
            ctx.lineTo(w, i);
            ctx.stroke();
        }
    }

    // Start
    init();

</script>
</body>
</html>